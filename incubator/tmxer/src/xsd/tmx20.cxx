// Copyright (C) 2005-2008 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/pre.hxx>

#include "tmx20.hxx"

namespace tmx20
{
  // segtypes
  // 

  segtypes::
  segtypes (value v)
  : ::xml_schema::token (_xsd_segtypes_literals_[v])
  {
  }

  segtypes::
  segtypes (const char* v)
  : ::xml_schema::token (v)
  {
  }

  segtypes::
  segtypes (const ::std::string& v)
  : ::xml_schema::token (v)
  {
  }

  segtypes::
  segtypes (const ::xml_schema::token& v)
  : ::xml_schema::token (v)
  {
  }

  segtypes::
  segtypes (const segtypes& v,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::token (v, f, c)
  {
  }

  segtypes& segtypes::
  operator= (value v)
  {
    static_cast< ::xml_schema::token& > (*this) = 
    ::xml_schema::token (_xsd_segtypes_literals_[v]);

    return *this;
  }


  // space
  // 

  space::
  space (value v)
  : ::xml_schema::token (_xsd_space_literals_[v])
  {
  }

  space::
  space (const char* v)
  : ::xml_schema::token (v)
  {
  }

  space::
  space (const ::std::string& v)
  : ::xml_schema::token (v)
  {
  }

  space::
  space (const ::xml_schema::token& v)
  : ::xml_schema::token (v)
  {
  }

  space::
  space (const space& v,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
  : ::xml_schema::token (v, f, c)
  {
  }

  space& space::
  operator= (value v)
  {
    static_cast< ::xml_schema::token& > (*this) = 
    ::xml_schema::token (_xsd_space_literals_[v]);

    return *this;
  }


  // assoc_type
  // 

  assoc_type::
  assoc_type (value v)
  : ::xml_schema::token (_xsd_assoc_type_literals_[v])
  {
  }

  assoc_type::
  assoc_type (const char* v)
  : ::xml_schema::token (v)
  {
  }

  assoc_type::
  assoc_type (const ::std::string& v)
  : ::xml_schema::token (v)
  {
  }

  assoc_type::
  assoc_type (const ::xml_schema::token& v)
  : ::xml_schema::token (v)
  {
  }

  assoc_type::
  assoc_type (const assoc_type& v,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::token (v, f, c)
  {
  }

  assoc_type& assoc_type::
  operator= (value v)
  {
    static_cast< ::xml_schema::token& > (*this) = 
    ::xml_schema::token (_xsd_assoc_type_literals_[v]);

    return *this;
  }


  // datatype
  // 

  datatype::
  datatype (value v)
  : ::xml_schema::token (_xsd_datatype_literals_[v])
  {
  }

  datatype::
  datatype (const char* v)
  : ::xml_schema::token (v)
  {
  }

  datatype::
  datatype (const ::std::string& v)
  : ::xml_schema::token (v)
  {
  }

  datatype::
  datatype (const ::xml_schema::token& v)
  : ::xml_schema::token (v)
  {
  }

  datatype::
  datatype (const datatype& v,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::token (v, f, c)
  {
  }

  datatype& datatype::
  operator= (value v)
  {
    static_cast< ::xml_schema::token& > (*this) = 
    ::xml_schema::token (_xsd_datatype_literals_[v]);

    return *this;
  }


  // paired_type
  // 

  paired_type::
  paired_type (value v)
  : ::xml_schema::token (_xsd_paired_type_literals_[v])
  {
  }

  paired_type::
  paired_type (const char* v)
  : ::xml_schema::token (v)
  {
  }

  paired_type::
  paired_type (const ::std::string& v)
  : ::xml_schema::token (v)
  {
  }

  paired_type::
  paired_type (const ::xml_schema::token& v)
  : ::xml_schema::token (v)
  {
  }

  paired_type::
  paired_type (const paired_type& v,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xml_schema::token (v, f, c)
  {
  }

  paired_type& paired_type::
  operator= (value v)
  {
    static_cast< ::xml_schema::token& > (*this) = 
    ::xml_schema::token (_xsd_paired_type_literals_[v]);

    return *this;
  }


  // placeholder_type
  // 

  placeholder_type::
  placeholder_type (value v)
  : ::xml_schema::token (_xsd_placeholder_type_literals_[v])
  {
  }

  placeholder_type::
  placeholder_type (const char* v)
  : ::xml_schema::token (v)
  {
  }

  placeholder_type::
  placeholder_type (const ::std::string& v)
  : ::xml_schema::token (v)
  {
  }

  placeholder_type::
  placeholder_type (const ::xml_schema::token& v)
  : ::xml_schema::token (v)
  {
  }

  placeholder_type::
  placeholder_type (const placeholder_type& v,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
  : ::xml_schema::token (v, f, c)
  {
  }

  placeholder_type& placeholder_type::
  operator= (value v)
  {
    static_cast< ::xml_schema::token& > (*this) = 
    ::xml_schema::token (_xsd_placeholder_type_literals_[v]);

    return *this;
  }


  // term_type
  // 

  term_type::
  term_type (value v)
  : ::xml_schema::token (_xsd_term_type_literals_[v])
  {
  }

  term_type::
  term_type (const char* v)
  : ::xml_schema::token (v)
  {
  }

  term_type::
  term_type (const ::std::string& v)
  : ::xml_schema::token (v)
  {
  }

  term_type::
  term_type (const ::xml_schema::token& v)
  : ::xml_schema::token (v)
  {
  }

  term_type::
  term_type (const term_type& v,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::xml_schema::token (v, f, c)
  {
  }

  term_type& term_type::
  operator= (value v)
  {
    static_cast< ::xml_schema::token& > (*this) = 
    ::xml_schema::token (_xsd_term_type_literals_[v]);

    return *this;
  }


  // context_type
  // 

  context_type::
  context_type (value v)
  : ::xml_schema::token (_xsd_context_type_literals_[v])
  {
  }

  context_type::
  context_type (const char* v)
  : ::xml_schema::token (v)
  {
  }

  context_type::
  context_type (const ::std::string& v)
  : ::xml_schema::token (v)
  {
  }

  context_type::
  context_type (const ::xml_schema::token& v)
  : ::xml_schema::token (v)
  {
  }

  context_type::
  context_type (const context_type& v,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
  : ::xml_schema::token (v, f, c)
  {
  }

  context_type& context_type::
  operator= (value v)
  {
    static_cast< ::xml_schema::token& > (*this) = 
    ::xml_schema::token (_xsd_context_type_literals_[v]);

    return *this;
  }


  // Custom
  // 


  // tmx
  // 

  const tmx::header_type& tmx::
  header () const
  {
    return this->header_.get ();
  }

  tmx::header_type& tmx::
  header ()
  {
    return this->header_.get ();
  }

  void tmx::
  header (const header_type& x)
  {
    this->header_.set (x);
  }

  void tmx::
  header (::std::auto_ptr< header_type > x)
  {
    this->header_.set (x);
  }

  const tmx::body_type& tmx::
  body () const
  {
    return this->body_.get ();
  }

  tmx::body_type& tmx::
  body ()
  {
    return this->body_.get ();
  }

  void tmx::
  body (const body_type& x)
  {
    this->body_.set (x);
  }

  void tmx::
  body (::std::auto_ptr< body_type > x)
  {
    this->body_.set (x);
  }

  const tmx::version_type& tmx::
  version () const
  {
    return this->version_.get ();
  }

  tmx::version_type& tmx::
  version ()
  {
    return this->version_.get ();
  }

  void tmx::
  version (const version_type& x)
  {
    this->version_.set (x);
  }

  void tmx::
  version (::std::auto_ptr< version_type > x)
  {
    this->version_.set (x);
  }


  // body
  // 

  const body::tu_sequence& body::
  tu () const
  {
    return this->tu_;
  }

  body::tu_sequence& body::
  tu ()
  {
    return this->tu_;
  }

  void body::
  tu (const tu_sequence& s)
  {
    this->tu_ = s;
  }


  // context
  // 

  const context::context_type_type& context::
  context_type () const
  {
    return this->context_type_.get ();
  }

  context::context_type_type& context::
  context_type ()
  {
    return this->context_type_.get ();
  }

  void context::
  context_type (const context_type_type& x)
  {
    this->context_type_.set (x);
  }

  void context::
  context_type (::std::auto_ptr< context_type_type > x)
  {
    this->context_type_.set (x);
  }


  // external_file
  // 

  const external_file::href_type& external_file::
  href () const
  {
    return this->href_.get ();
  }

  external_file::href_type& external_file::
  href ()
  {
    return this->href_.get ();
  }

  void external_file::
  href (const href_type& x)
  {
    this->href_.set (x);
  }

  void external_file::
  href (::std::auto_ptr< href_type > x)
  {
    this->href_.set (x);
  }

  const external_file::crc_optional& external_file::
  crc () const
  {
    return this->crc_;
  }

  external_file::crc_optional& external_file::
  crc ()
  {
    return this->crc_;
  }

  void external_file::
  crc (const crc_type& x)
  {
    this->crc_.set (x);
  }

  void external_file::
  crc (const crc_optional& x)
  {
    this->crc_ = x;
  }

  void external_file::
  crc (::std::auto_ptr< crc_type > x)
  {
    this->crc_.set (x);
  }

  const external_file::uid_optional& external_file::
  uid () const
  {
    return this->uid_;
  }

  external_file::uid_optional& external_file::
  uid ()
  {
    return this->uid_;
  }

  void external_file::
  uid (const uid_type& x)
  {
    this->uid_.set (x);
  }

  void external_file::
  uid (const uid_optional& x)
  {
    this->uid_ = x;
  }

  void external_file::
  uid (::std::auto_ptr< uid_type > x)
  {
    this->uid_.set (x);
  }


  // header
  // 

  const header::note_sequence& header::
  note () const
  {
    return this->note_;
  }

  header::note_sequence& header::
  note ()
  {
    return this->note_;
  }

  void header::
  note (const note_sequence& s)
  {
    this->note_ = s;
  }

  const header::prop_sequence& header::
  prop () const
  {
    return this->prop_;
  }

  header::prop_sequence& header::
  prop ()
  {
    return this->prop_;
  }

  void header::
  prop (const prop_sequence& s)
  {
    this->prop_ = s;
  }

  const header::inline_data_optional& header::
  inline_data () const
  {
    return this->inline_data_;
  }

  header::inline_data_optional& header::
  inline_data ()
  {
    return this->inline_data_;
  }

  void header::
  inline_data (const inline_data_type& x)
  {
    this->inline_data_.set (x);
  }

  void header::
  inline_data (const inline_data_optional& x)
  {
    this->inline_data_ = x;
  }

  void header::
  inline_data (::std::auto_ptr< inline_data_type > x)
  {
    this->inline_data_.set (x);
  }

  const header::segmentation_optional& header::
  segmentation () const
  {
    return this->segmentation_;
  }

  header::segmentation_optional& header::
  segmentation ()
  {
    return this->segmentation_;
  }

  void header::
  segmentation (const segmentation_type& x)
  {
    this->segmentation_.set (x);
  }

  void header::
  segmentation (const segmentation_optional& x)
  {
    this->segmentation_ = x;
  }

  void header::
  segmentation (::std::auto_ptr< segmentation_type > x)
  {
    this->segmentation_.set (x);
  }

  const header::creationtool_type& header::
  creationtool () const
  {
    return this->creationtool_.get ();
  }

  header::creationtool_type& header::
  creationtool ()
  {
    return this->creationtool_.get ();
  }

  void header::
  creationtool (const creationtool_type& x)
  {
    this->creationtool_.set (x);
  }

  void header::
  creationtool (::std::auto_ptr< creationtool_type > x)
  {
    this->creationtool_.set (x);
  }

  const header::creationtoolversion_type& header::
  creationtoolversion () const
  {
    return this->creationtoolversion_.get ();
  }

  header::creationtoolversion_type& header::
  creationtoolversion ()
  {
    return this->creationtoolversion_.get ();
  }

  void header::
  creationtoolversion (const creationtoolversion_type& x)
  {
    this->creationtoolversion_.set (x);
  }

  void header::
  creationtoolversion (::std::auto_ptr< creationtoolversion_type > x)
  {
    this->creationtoolversion_.set (x);
  }

  const header::segtype_type& header::
  segtype () const
  {
    return this->segtype_.get ();
  }

  header::segtype_type& header::
  segtype ()
  {
    return this->segtype_.get ();
  }

  void header::
  segtype (const segtype_type& x)
  {
    this->segtype_.set (x);
  }

  void header::
  segtype (::std::auto_ptr< segtype_type > x)
  {
    this->segtype_.set (x);
  }

  const header::o_tmf_type& header::
  o_tmf () const
  {
    return this->o_tmf_.get ();
  }

  header::o_tmf_type& header::
  o_tmf ()
  {
    return this->o_tmf_.get ();
  }

  void header::
  o_tmf (const o_tmf_type& x)
  {
    this->o_tmf_.set (x);
  }

  void header::
  o_tmf (::std::auto_ptr< o_tmf_type > x)
  {
    this->o_tmf_.set (x);
  }

  const header::adminlang_type& header::
  adminlang () const
  {
    return this->adminlang_.get ();
  }

  header::adminlang_type& header::
  adminlang ()
  {
    return this->adminlang_.get ();
  }

  void header::
  adminlang (const adminlang_type& x)
  {
    this->adminlang_.set (x);
  }

  void header::
  adminlang (::std::auto_ptr< adminlang_type > x)
  {
    this->adminlang_.set (x);
  }

  const header::srclang_type& header::
  srclang () const
  {
    return this->srclang_.get ();
  }

  header::srclang_type& header::
  srclang ()
  {
    return this->srclang_.get ();
  }

  void header::
  srclang (const srclang_type& x)
  {
    this->srclang_.set (x);
  }

  void header::
  srclang (::std::auto_ptr< srclang_type > x)
  {
    this->srclang_.set (x);
  }

  const header::datatype_type& header::
  datatype () const
  {
    return this->datatype_.get ();
  }

  header::datatype_type& header::
  datatype ()
  {
    return this->datatype_.get ();
  }

  void header::
  datatype (const datatype_type& x)
  {
    this->datatype_.set (x);
  }

  void header::
  datatype (::std::auto_ptr< datatype_type > x)
  {
    this->datatype_.set (x);
  }

  const header::o_encoding_optional& header::
  o_encoding () const
  {
    return this->o_encoding_;
  }

  header::o_encoding_optional& header::
  o_encoding ()
  {
    return this->o_encoding_;
  }

  void header::
  o_encoding (const o_encoding_type& x)
  {
    this->o_encoding_.set (x);
  }

  void header::
  o_encoding (const o_encoding_optional& x)
  {
    this->o_encoding_ = x;
  }

  void header::
  o_encoding (::std::auto_ptr< o_encoding_type > x)
  {
    this->o_encoding_.set (x);
  }

  const header::creationdate_optional& header::
  creationdate () const
  {
    return this->creationdate_;
  }

  header::creationdate_optional& header::
  creationdate ()
  {
    return this->creationdate_;
  }

  void header::
  creationdate (const creationdate_type& x)
  {
    this->creationdate_.set (x);
  }

  void header::
  creationdate (const creationdate_optional& x)
  {
    this->creationdate_ = x;
  }

  void header::
  creationdate (::std::auto_ptr< creationdate_type > x)
  {
    this->creationdate_.set (x);
  }

  const header::creationid_optional& header::
  creationid () const
  {
    return this->creationid_;
  }

  header::creationid_optional& header::
  creationid ()
  {
    return this->creationid_;
  }

  void header::
  creationid (const creationid_type& x)
  {
    this->creationid_.set (x);
  }

  void header::
  creationid (const creationid_optional& x)
  {
    this->creationid_ = x;
  }

  void header::
  creationid (::std::auto_ptr< creationid_type > x)
  {
    this->creationid_.set (x);
  }

  const header::changedate_optional& header::
  changedate () const
  {
    return this->changedate_;
  }

  header::changedate_optional& header::
  changedate ()
  {
    return this->changedate_;
  }

  void header::
  changedate (const changedate_type& x)
  {
    this->changedate_.set (x);
  }

  void header::
  changedate (const changedate_optional& x)
  {
    this->changedate_ = x;
  }

  void header::
  changedate (::std::auto_ptr< changedate_type > x)
  {
    this->changedate_.set (x);
  }

  const header::changeid_optional& header::
  changeid () const
  {
    return this->changeid_;
  }

  header::changeid_optional& header::
  changeid ()
  {
    return this->changeid_;
  }

  void header::
  changeid (const changeid_type& x)
  {
    this->changeid_.set (x);
  }

  void header::
  changeid (const changeid_optional& x)
  {
    this->changeid_ = x;
  }

  void header::
  changeid (::std::auto_ptr< changeid_type > x)
  {
    this->changeid_.set (x);
  }


  // inline_data
  // 

  const inline_data::tag_sequence& inline_data::
  tag () const
  {
    return this->tag_;
  }

  inline_data::tag_sequence& inline_data::
  tag ()
  {
    return this->tag_;
  }

  void inline_data::
  tag (const tag_sequence& s)
  {
    this->tag_ = s;
  }


  // internal_file
  // 


  // note
  // 

  const note::o_encoding_optional& note::
  o_encoding () const
  {
    return this->o_encoding_;
  }

  note::o_encoding_optional& note::
  o_encoding ()
  {
    return this->o_encoding_;
  }

  void note::
  o_encoding (const o_encoding_type& x)
  {
    this->o_encoding_.set (x);
  }

  void note::
  o_encoding (const o_encoding_optional& x)
  {
    this->o_encoding_ = x;
  }

  void note::
  o_encoding (::std::auto_ptr< o_encoding_type > x)
  {
    this->o_encoding_.set (x);
  }

  const note::lang_optional& note::
  lang () const
  {
    return this->lang_;
  }

  note::lang_optional& note::
  lang ()
  {
    return this->lang_;
  }

  void note::
  lang (const lang_type& x)
  {
    this->lang_.set (x);
  }

  void note::
  lang (const lang_optional& x)
  {
    this->lang_ = x;
  }

  void note::
  lang (::std::auto_ptr< lang_type > x)
  {
    this->lang_.set (x);
  }

  const note::creationdate_optional& note::
  creationdate () const
  {
    return this->creationdate_;
  }

  note::creationdate_optional& note::
  creationdate ()
  {
    return this->creationdate_;
  }

  void note::
  creationdate (const creationdate_type& x)
  {
    this->creationdate_.set (x);
  }

  void note::
  creationdate (const creationdate_optional& x)
  {
    this->creationdate_ = x;
  }

  void note::
  creationdate (::std::auto_ptr< creationdate_type > x)
  {
    this->creationdate_.set (x);
  }

  const note::creationid_optional& note::
  creationid () const
  {
    return this->creationid_;
  }

  note::creationid_optional& note::
  creationid ()
  {
    return this->creationid_;
  }

  void note::
  creationid (const creationid_type& x)
  {
    this->creationid_.set (x);
  }

  void note::
  creationid (const creationid_optional& x)
  {
    this->creationid_ = x;
  }

  void note::
  creationid (::std::auto_ptr< creationid_type > x)
  {
    this->creationid_.set (x);
  }

  const note::changedate_optional& note::
  changedate () const
  {
    return this->changedate_;
  }

  note::changedate_optional& note::
  changedate ()
  {
    return this->changedate_;
  }

  void note::
  changedate (const changedate_type& x)
  {
    this->changedate_.set (x);
  }

  void note::
  changedate (const changedate_optional& x)
  {
    this->changedate_ = x;
  }

  void note::
  changedate (::std::auto_ptr< changedate_type > x)
  {
    this->changedate_.set (x);
  }

  const note::changeid_optional& note::
  changeid () const
  {
    return this->changeid_;
  }

  note::changeid_optional& note::
  changeid ()
  {
    return this->changeid_;
  }

  void note::
  changeid (const changeid_type& x)
  {
    this->changeid_.set (x);
  }

  void note::
  changeid (const changeid_optional& x)
  {
    this->changeid_ = x;
  }

  void note::
  changeid (::std::auto_ptr< changeid_type > x)
  {
    this->changeid_.set (x);
  }


  // prop
  // 

  const prop::name_type& prop::
  name () const
  {
    return this->name_.get ();
  }

  prop::name_type& prop::
  name ()
  {
    return this->name_.get ();
  }

  void prop::
  name (const name_type& x)
  {
    this->name_.set (x);
  }

  void prop::
  name (::std::auto_ptr< name_type > x)
  {
    this->name_.set (x);
  }

  const prop::lang_optional& prop::
  lang () const
  {
    return this->lang_;
  }

  prop::lang_optional& prop::
  lang ()
  {
    return this->lang_;
  }

  void prop::
  lang (const lang_type& x)
  {
    this->lang_.set (x);
  }

  void prop::
  lang (const lang_optional& x)
  {
    this->lang_ = x;
  }

  void prop::
  lang (::std::auto_ptr< lang_type > x)
  {
    this->lang_.set (x);
  }

  const prop::o_encoding_optional& prop::
  o_encoding () const
  {
    return this->o_encoding_;
  }

  prop::o_encoding_optional& prop::
  o_encoding ()
  {
    return this->o_encoding_;
  }

  void prop::
  o_encoding (const o_encoding_type& x)
  {
    this->o_encoding_.set (x);
  }

  void prop::
  o_encoding (const o_encoding_optional& x)
  {
    this->o_encoding_ = x;
  }

  void prop::
  o_encoding (::std::auto_ptr< o_encoding_type > x)
  {
    this->o_encoding_.set (x);
  }


  // seg
  // 

  const seg::bpt_sequence& seg::
  bpt () const
  {
    return this->bpt_;
  }

  seg::bpt_sequence& seg::
  bpt ()
  {
    return this->bpt_;
  }

  void seg::
  bpt (const bpt_sequence& s)
  {
    this->bpt_ = s;
  }

  const seg::ept_sequence& seg::
  ept () const
  {
    return this->ept_;
  }

  seg::ept_sequence& seg::
  ept ()
  {
    return this->ept_;
  }

  void seg::
  ept (const ept_sequence& s)
  {
    this->ept_ = s;
  }

  const seg::ph_sequence& seg::
  ph () const
  {
    return this->ph_;
  }

  seg::ph_sequence& seg::
  ph ()
  {
    return this->ph_;
  }

  void seg::
  ph (const ph_sequence& s)
  {
    this->ph_ = s;
  }

  const seg::hi_sequence& seg::
  hi () const
  {
    return this->hi_;
  }

  seg::hi_sequence& seg::
  hi ()
  {
    return this->hi_;
  }

  void seg::
  hi (const hi_sequence& s)
  {
    this->hi_ = s;
  }

  const seg::x_sequence& seg::
  x () const
  {
    return this->x_;
  }

  seg::x_sequence& seg::
  x ()
  {
    return this->x_;
  }

  void seg::
  x (const x_sequence& s)
  {
    this->x_ = s;
  }

  const seg::g_sequence& seg::
  g () const
  {
    return this->g_;
  }

  seg::g_sequence& seg::
  g ()
  {
    return this->g_;
  }

  void seg::
  g (const g_sequence& s)
  {
    this->g_ = s;
  }

  const seg::space_type& seg::
  space () const
  {
    return this->space_.get ();
  }

  seg::space_type& seg::
  space ()
  {
    return this->space_.get ();
  }

  void seg::
  space (const space_type& x)
  {
    this->space_.set (x);
  }

  void seg::
  space (::std::auto_ptr< space_type > x)
  {
    this->space_.set (x);
  }

  const seg::space_type& seg::
  space_default_value ()
  {
    return space_default_value_;
  }


  // segmentation
  // 

  const segmentation::internal_file_optional& segmentation::
  internal_file () const
  {
    return this->internal_file_;
  }

  segmentation::internal_file_optional& segmentation::
  internal_file ()
  {
    return this->internal_file_;
  }

  void segmentation::
  internal_file (const internal_file_type& x)
  {
    this->internal_file_.set (x);
  }

  void segmentation::
  internal_file (const internal_file_optional& x)
  {
    this->internal_file_ = x;
  }

  void segmentation::
  internal_file (::std::auto_ptr< internal_file_type > x)
  {
    this->internal_file_.set (x);
  }

  const segmentation::external_file_optional& segmentation::
  external_file () const
  {
    return this->external_file_;
  }

  segmentation::external_file_optional& segmentation::
  external_file ()
  {
    return this->external_file_;
  }

  void segmentation::
  external_file (const external_file_type& x)
  {
    this->external_file_.set (x);
  }

  void segmentation::
  external_file (const external_file_optional& x)
  {
    this->external_file_ = x;
  }

  void segmentation::
  external_file (::std::auto_ptr< external_file_type > x)
  {
    this->external_file_.set (x);
  }


  // tag
  // 

  const tag::id_type& tag::
  id () const
  {
    return this->id_.get ();
  }

  tag::id_type& tag::
  id ()
  {
    return this->id_.get ();
  }

  void tag::
  id (const id_type& x)
  {
    this->id_.set (x);
  }

  void tag::
  id (::std::auto_ptr< id_type > x)
  {
    this->id_.set (x);
  }

  const tag::endmrk_optional& tag::
  endmrk () const
  {
    return this->endmrk_;
  }

  tag::endmrk_optional& tag::
  endmrk ()
  {
    return this->endmrk_;
  }

  void tag::
  endmrk (const endmrk_type& x)
  {
    this->endmrk_.set (x);
  }

  void tag::
  endmrk (const endmrk_optional& x)
  {
    this->endmrk_ = x;
  }

  void tag::
  endmrk (::std::auto_ptr< endmrk_type > x)
  {
    this->endmrk_.set (x);
  }

  const tag::type_type& tag::
  type () const
  {
    return this->type_.get ();
  }

  tag::type_type& tag::
  type ()
  {
    return this->type_.get ();
  }

  void tag::
  type (const type_type& x)
  {
    this->type_.set (x);
  }

  void tag::
  type (::std::auto_ptr< type_type > x)
  {
    this->type_.set (x);
  }

  const tag::o_encoding_optional& tag::
  o_encoding () const
  {
    return this->o_encoding_;
  }

  tag::o_encoding_optional& tag::
  o_encoding ()
  {
    return this->o_encoding_;
  }

  void tag::
  o_encoding (const o_encoding_type& x)
  {
    this->o_encoding_.set (x);
  }

  void tag::
  o_encoding (const o_encoding_optional& x)
  {
    this->o_encoding_ = x;
  }

  void tag::
  o_encoding (::std::auto_ptr< o_encoding_type > x)
  {
    this->o_encoding_.set (x);
  }


  // tu
  // 

  const tu::note_sequence& tu::
  note () const
  {
    return this->note_;
  }

  tu::note_sequence& tu::
  note ()
  {
    return this->note_;
  }

  void tu::
  note (const note_sequence& s)
  {
    this->note_ = s;
  }

  const tu::prop_sequence& tu::
  prop () const
  {
    return this->prop_;
  }

  tu::prop_sequence& tu::
  prop ()
  {
    return this->prop_;
  }

  void tu::
  prop (const prop_sequence& s)
  {
    this->prop_ = s;
  }

  const tu::context_sequence& tu::
  context () const
  {
    return this->context_;
  }

  tu::context_sequence& tu::
  context ()
  {
    return this->context_;
  }

  void tu::
  context (const context_sequence& s)
  {
    this->context_ = s;
  }

  const tu::tuv_sequence& tu::
  tuv () const
  {
    return this->tuv_;
  }

  tu::tuv_sequence& tu::
  tuv ()
  {
    return this->tuv_;
  }

  void tu::
  tuv (const tuv_sequence& s)
  {
    this->tuv_ = s;
  }

  const tu::tuid_optional& tu::
  tuid () const
  {
    return this->tuid_;
  }

  tu::tuid_optional& tu::
  tuid ()
  {
    return this->tuid_;
  }

  void tu::
  tuid (const tuid_type& x)
  {
    this->tuid_.set (x);
  }

  void tu::
  tuid (const tuid_optional& x)
  {
    this->tuid_ = x;
  }

  void tu::
  tuid (::std::auto_ptr< tuid_type > x)
  {
    this->tuid_.set (x);
  }

  const tu::o_encoding_optional& tu::
  o_encoding () const
  {
    return this->o_encoding_;
  }

  tu::o_encoding_optional& tu::
  o_encoding ()
  {
    return this->o_encoding_;
  }

  void tu::
  o_encoding (const o_encoding_type& x)
  {
    this->o_encoding_.set (x);
  }

  void tu::
  o_encoding (const o_encoding_optional& x)
  {
    this->o_encoding_ = x;
  }

  void tu::
  o_encoding (::std::auto_ptr< o_encoding_type > x)
  {
    this->o_encoding_.set (x);
  }

  const tu::datatype_type& tu::
  datatype () const
  {
    return this->datatype_.get ();
  }

  tu::datatype_type& tu::
  datatype ()
  {
    return this->datatype_.get ();
  }

  void tu::
  datatype (const datatype_type& x)
  {
    this->datatype_.set (x);
  }

  void tu::
  datatype (::std::auto_ptr< datatype_type > x)
  {
    this->datatype_.set (x);
  }

  const tu::datatype_type& tu::
  datatype_default_value ()
  {
    return datatype_default_value_;
  }

  const tu::usagecount_optional& tu::
  usagecount () const
  {
    return this->usagecount_;
  }

  tu::usagecount_optional& tu::
  usagecount ()
  {
    return this->usagecount_;
  }

  void tu::
  usagecount (const usagecount_type& x)
  {
    this->usagecount_.set (x);
  }

  void tu::
  usagecount (const usagecount_optional& x)
  {
    this->usagecount_ = x;
  }

  void tu::
  usagecount (::std::auto_ptr< usagecount_type > x)
  {
    this->usagecount_.set (x);
  }

  const tu::lastusagedate_optional& tu::
  lastusagedate () const
  {
    return this->lastusagedate_;
  }

  tu::lastusagedate_optional& tu::
  lastusagedate ()
  {
    return this->lastusagedate_;
  }

  void tu::
  lastusagedate (const lastusagedate_type& x)
  {
    this->lastusagedate_.set (x);
  }

  void tu::
  lastusagedate (const lastusagedate_optional& x)
  {
    this->lastusagedate_ = x;
  }

  void tu::
  lastusagedate (::std::auto_ptr< lastusagedate_type > x)
  {
    this->lastusagedate_.set (x);
  }

  const tu::creationtool_optional& tu::
  creationtool () const
  {
    return this->creationtool_;
  }

  tu::creationtool_optional& tu::
  creationtool ()
  {
    return this->creationtool_;
  }

  void tu::
  creationtool (const creationtool_type& x)
  {
    this->creationtool_.set (x);
  }

  void tu::
  creationtool (const creationtool_optional& x)
  {
    this->creationtool_ = x;
  }

  void tu::
  creationtool (::std::auto_ptr< creationtool_type > x)
  {
    this->creationtool_.set (x);
  }

  const tu::creationtoolversion_optional& tu::
  creationtoolversion () const
  {
    return this->creationtoolversion_;
  }

  tu::creationtoolversion_optional& tu::
  creationtoolversion ()
  {
    return this->creationtoolversion_;
  }

  void tu::
  creationtoolversion (const creationtoolversion_type& x)
  {
    this->creationtoolversion_.set (x);
  }

  void tu::
  creationtoolversion (const creationtoolversion_optional& x)
  {
    this->creationtoolversion_ = x;
  }

  void tu::
  creationtoolversion (::std::auto_ptr< creationtoolversion_type > x)
  {
    this->creationtoolversion_.set (x);
  }

  const tu::creationdate_optional& tu::
  creationdate () const
  {
    return this->creationdate_;
  }

  tu::creationdate_optional& tu::
  creationdate ()
  {
    return this->creationdate_;
  }

  void tu::
  creationdate (const creationdate_type& x)
  {
    this->creationdate_.set (x);
  }

  void tu::
  creationdate (const creationdate_optional& x)
  {
    this->creationdate_ = x;
  }

  void tu::
  creationdate (::std::auto_ptr< creationdate_type > x)
  {
    this->creationdate_.set (x);
  }

  const tu::creationid_optional& tu::
  creationid () const
  {
    return this->creationid_;
  }

  tu::creationid_optional& tu::
  creationid ()
  {
    return this->creationid_;
  }

  void tu::
  creationid (const creationid_type& x)
  {
    this->creationid_.set (x);
  }

  void tu::
  creationid (const creationid_optional& x)
  {
    this->creationid_ = x;
  }

  void tu::
  creationid (::std::auto_ptr< creationid_type > x)
  {
    this->creationid_.set (x);
  }

  const tu::changedate_optional& tu::
  changedate () const
  {
    return this->changedate_;
  }

  tu::changedate_optional& tu::
  changedate ()
  {
    return this->changedate_;
  }

  void tu::
  changedate (const changedate_type& x)
  {
    this->changedate_.set (x);
  }

  void tu::
  changedate (const changedate_optional& x)
  {
    this->changedate_ = x;
  }

  void tu::
  changedate (::std::auto_ptr< changedate_type > x)
  {
    this->changedate_.set (x);
  }

  const tu::segtype_optional& tu::
  segtype () const
  {
    return this->segtype_;
  }

  tu::segtype_optional& tu::
  segtype ()
  {
    return this->segtype_;
  }

  void tu::
  segtype (const segtype_type& x)
  {
    this->segtype_.set (x);
  }

  void tu::
  segtype (const segtype_optional& x)
  {
    this->segtype_ = x;
  }

  void tu::
  segtype (::std::auto_ptr< segtype_type > x)
  {
    this->segtype_.set (x);
  }

  const tu::changeid_optional& tu::
  changeid () const
  {
    return this->changeid_;
  }

  tu::changeid_optional& tu::
  changeid ()
  {
    return this->changeid_;
  }

  void tu::
  changeid (const changeid_type& x)
  {
    this->changeid_.set (x);
  }

  void tu::
  changeid (const changeid_optional& x)
  {
    this->changeid_ = x;
  }

  void tu::
  changeid (::std::auto_ptr< changeid_type > x)
  {
    this->changeid_.set (x);
  }

  const tu::o_tmf_optional& tu::
  o_tmf () const
  {
    return this->o_tmf_;
  }

  tu::o_tmf_optional& tu::
  o_tmf ()
  {
    return this->o_tmf_;
  }

  void tu::
  o_tmf (const o_tmf_type& x)
  {
    this->o_tmf_.set (x);
  }

  void tu::
  o_tmf (const o_tmf_optional& x)
  {
    this->o_tmf_ = x;
  }

  void tu::
  o_tmf (::std::auto_ptr< o_tmf_type > x)
  {
    this->o_tmf_.set (x);
  }

  const tu::srclang_optional& tu::
  srclang () const
  {
    return this->srclang_;
  }

  tu::srclang_optional& tu::
  srclang ()
  {
    return this->srclang_;
  }

  void tu::
  srclang (const srclang_type& x)
  {
    this->srclang_.set (x);
  }

  void tu::
  srclang (const srclang_optional& x)
  {
    this->srclang_ = x;
  }

  void tu::
  srclang (::std::auto_ptr< srclang_type > x)
  {
    this->srclang_.set (x);
  }

  const tu::group_optional& tu::
  group () const
  {
    return this->group_;
  }

  tu::group_optional& tu::
  group ()
  {
    return this->group_;
  }

  void tu::
  group (const group_type& x)
  {
    this->group_.set (x);
  }

  void tu::
  group (const group_optional& x)
  {
    this->group_ = x;
  }

  void tu::
  group (::std::auto_ptr< group_type > x)
  {
    this->group_.set (x);
  }

  const tu::g_order_optional& tu::
  g_order () const
  {
    return this->g_order_;
  }

  tu::g_order_optional& tu::
  g_order ()
  {
    return this->g_order_;
  }

  void tu::
  g_order (const g_order_type& x)
  {
    this->g_order_.set (x);
  }

  void tu::
  g_order (const g_order_optional& x)
  {
    this->g_order_ = x;
  }

  void tu::
  g_order (::std::auto_ptr< g_order_type > x)
  {
    this->g_order_.set (x);
  }


  // tuv
  // 

  const tuv::note_sequence& tuv::
  note () const
  {
    return this->note_;
  }

  tuv::note_sequence& tuv::
  note ()
  {
    return this->note_;
  }

  void tuv::
  note (const note_sequence& s)
  {
    this->note_ = s;
  }

  const tuv::prop_sequence& tuv::
  prop () const
  {
    return this->prop_;
  }

  tuv::prop_sequence& tuv::
  prop ()
  {
    return this->prop_;
  }

  void tuv::
  prop (const prop_sequence& s)
  {
    this->prop_ = s;
  }

  const tuv::seg_type& tuv::
  seg () const
  {
    return this->seg_.get ();
  }

  tuv::seg_type& tuv::
  seg ()
  {
    return this->seg_.get ();
  }

  void tuv::
  seg (const seg_type& x)
  {
    this->seg_.set (x);
  }

  void tuv::
  seg (::std::auto_ptr< seg_type > x)
  {
    this->seg_.set (x);
  }

  const tuv::lang_type& tuv::
  lang () const
  {
    return this->lang_.get ();
  }

  tuv::lang_type& tuv::
  lang ()
  {
    return this->lang_.get ();
  }

  void tuv::
  lang (const lang_type& x)
  {
    this->lang_.set (x);
  }

  void tuv::
  lang (::std::auto_ptr< lang_type > x)
  {
    this->lang_.set (x);
  }

  const tuv::o_encoding_optional& tuv::
  o_encoding () const
  {
    return this->o_encoding_;
  }

  tuv::o_encoding_optional& tuv::
  o_encoding ()
  {
    return this->o_encoding_;
  }

  void tuv::
  o_encoding (const o_encoding_type& x)
  {
    this->o_encoding_.set (x);
  }

  void tuv::
  o_encoding (const o_encoding_optional& x)
  {
    this->o_encoding_ = x;
  }

  void tuv::
  o_encoding (::std::auto_ptr< o_encoding_type > x)
  {
    this->o_encoding_.set (x);
  }

  const tuv::datatype_type& tuv::
  datatype () const
  {
    return this->datatype_.get ();
  }

  tuv::datatype_type& tuv::
  datatype ()
  {
    return this->datatype_.get ();
  }

  void tuv::
  datatype (const datatype_type& x)
  {
    this->datatype_.set (x);
  }

  void tuv::
  datatype (::std::auto_ptr< datatype_type > x)
  {
    this->datatype_.set (x);
  }

  const tuv::datatype_type& tuv::
  datatype_default_value ()
  {
    return datatype_default_value_;
  }

  const tuv::usagecount_optional& tuv::
  usagecount () const
  {
    return this->usagecount_;
  }

  tuv::usagecount_optional& tuv::
  usagecount ()
  {
    return this->usagecount_;
  }

  void tuv::
  usagecount (const usagecount_type& x)
  {
    this->usagecount_.set (x);
  }

  void tuv::
  usagecount (const usagecount_optional& x)
  {
    this->usagecount_ = x;
  }

  void tuv::
  usagecount (::std::auto_ptr< usagecount_type > x)
  {
    this->usagecount_.set (x);
  }

  const tuv::lastusagedate_optional& tuv::
  lastusagedate () const
  {
    return this->lastusagedate_;
  }

  tuv::lastusagedate_optional& tuv::
  lastusagedate ()
  {
    return this->lastusagedate_;
  }

  void tuv::
  lastusagedate (const lastusagedate_type& x)
  {
    this->lastusagedate_.set (x);
  }

  void tuv::
  lastusagedate (const lastusagedate_optional& x)
  {
    this->lastusagedate_ = x;
  }

  void tuv::
  lastusagedate (::std::auto_ptr< lastusagedate_type > x)
  {
    this->lastusagedate_.set (x);
  }

  const tuv::creationtool_optional& tuv::
  creationtool () const
  {
    return this->creationtool_;
  }

  tuv::creationtool_optional& tuv::
  creationtool ()
  {
    return this->creationtool_;
  }

  void tuv::
  creationtool (const creationtool_type& x)
  {
    this->creationtool_.set (x);
  }

  void tuv::
  creationtool (const creationtool_optional& x)
  {
    this->creationtool_ = x;
  }

  void tuv::
  creationtool (::std::auto_ptr< creationtool_type > x)
  {
    this->creationtool_.set (x);
  }

  const tuv::creationtoolversion_optional& tuv::
  creationtoolversion () const
  {
    return this->creationtoolversion_;
  }

  tuv::creationtoolversion_optional& tuv::
  creationtoolversion ()
  {
    return this->creationtoolversion_;
  }

  void tuv::
  creationtoolversion (const creationtoolversion_type& x)
  {
    this->creationtoolversion_.set (x);
  }

  void tuv::
  creationtoolversion (const creationtoolversion_optional& x)
  {
    this->creationtoolversion_ = x;
  }

  void tuv::
  creationtoolversion (::std::auto_ptr< creationtoolversion_type > x)
  {
    this->creationtoolversion_.set (x);
  }

  const tuv::creationdate_optional& tuv::
  creationdate () const
  {
    return this->creationdate_;
  }

  tuv::creationdate_optional& tuv::
  creationdate ()
  {
    return this->creationdate_;
  }

  void tuv::
  creationdate (const creationdate_type& x)
  {
    this->creationdate_.set (x);
  }

  void tuv::
  creationdate (const creationdate_optional& x)
  {
    this->creationdate_ = x;
  }

  void tuv::
  creationdate (::std::auto_ptr< creationdate_type > x)
  {
    this->creationdate_.set (x);
  }

  const tuv::creationid_optional& tuv::
  creationid () const
  {
    return this->creationid_;
  }

  tuv::creationid_optional& tuv::
  creationid ()
  {
    return this->creationid_;
  }

  void tuv::
  creationid (const creationid_type& x)
  {
    this->creationid_.set (x);
  }

  void tuv::
  creationid (const creationid_optional& x)
  {
    this->creationid_ = x;
  }

  void tuv::
  creationid (::std::auto_ptr< creationid_type > x)
  {
    this->creationid_.set (x);
  }

  const tuv::changedate_optional& tuv::
  changedate () const
  {
    return this->changedate_;
  }

  tuv::changedate_optional& tuv::
  changedate ()
  {
    return this->changedate_;
  }

  void tuv::
  changedate (const changedate_type& x)
  {
    this->changedate_.set (x);
  }

  void tuv::
  changedate (const changedate_optional& x)
  {
    this->changedate_ = x;
  }

  void tuv::
  changedate (::std::auto_ptr< changedate_type > x)
  {
    this->changedate_.set (x);
  }

  const tuv::o_tmf_optional& tuv::
  o_tmf () const
  {
    return this->o_tmf_;
  }

  tuv::o_tmf_optional& tuv::
  o_tmf ()
  {
    return this->o_tmf_;
  }

  void tuv::
  o_tmf (const o_tmf_type& x)
  {
    this->o_tmf_.set (x);
  }

  void tuv::
  o_tmf (const o_tmf_optional& x)
  {
    this->o_tmf_ = x;
  }

  void tuv::
  o_tmf (::std::auto_ptr< o_tmf_type > x)
  {
    this->o_tmf_.set (x);
  }

  const tuv::changeid_optional& tuv::
  changeid () const
  {
    return this->changeid_;
  }

  tuv::changeid_optional& tuv::
  changeid ()
  {
    return this->changeid_;
  }

  void tuv::
  changeid (const changeid_type& x)
  {
    this->changeid_.set (x);
  }

  void tuv::
  changeid (const changeid_optional& x)
  {
    this->changeid_ = x;
  }

  void tuv::
  changeid (::std::auto_ptr< changeid_type > x)
  {
    this->changeid_.set (x);
  }


  // bpt
  // 

  const bpt::sub_sequence& bpt::
  sub () const
  {
    return this->sub_;
  }

  bpt::sub_sequence& bpt::
  sub ()
  {
    return this->sub_;
  }

  void bpt::
  sub (const sub_sequence& s)
  {
    this->sub_ = s;
  }

  const bpt::i_type& bpt::
  i () const
  {
    return this->i_.get ();
  }

  bpt::i_type& bpt::
  i ()
  {
    return this->i_.get ();
  }

  void bpt::
  i (const i_type& x)
  {
    this->i_.set (x);
  }

  void bpt::
  i (::std::auto_ptr< i_type > x)
  {
    this->i_.set (x);
  }

  const bpt::x_optional& bpt::
  x () const
  {
    return this->x_;
  }

  bpt::x_optional& bpt::
  x ()
  {
    return this->x_;
  }

  void bpt::
  x (const x_type& x)
  {
    this->x_.set (x);
  }

  void bpt::
  x (const x_optional& x)
  {
    this->x_ = x;
  }

  void bpt::
  x (::std::auto_ptr< x_type > x)
  {
    this->x_.set (x);
  }

  const bpt::equiv_text_optional& bpt::
  equiv_text () const
  {
    return this->equiv_text_;
  }

  bpt::equiv_text_optional& bpt::
  equiv_text ()
  {
    return this->equiv_text_;
  }

  void bpt::
  equiv_text (const equiv_text_type& x)
  {
    this->equiv_text_.set (x);
  }

  void bpt::
  equiv_text (const equiv_text_optional& x)
  {
    this->equiv_text_ = x;
  }

  void bpt::
  equiv_text (::std::auto_ptr< equiv_text_type > x)
  {
    this->equiv_text_.set (x);
  }

  const bpt::type_type& bpt::
  type () const
  {
    return this->type_.get ();
  }

  bpt::type_type& bpt::
  type ()
  {
    return this->type_.get ();
  }

  void bpt::
  type (const type_type& x)
  {
    this->type_.set (x);
  }

  void bpt::
  type (::std::auto_ptr< type_type > x)
  {
    this->type_.set (x);
  }


  // ept
  // 

  const ept::sub_sequence& ept::
  sub () const
  {
    return this->sub_;
  }

  ept::sub_sequence& ept::
  sub ()
  {
    return this->sub_;
  }

  void ept::
  sub (const sub_sequence& s)
  {
    this->sub_ = s;
  }

  const ept::i_type& ept::
  i () const
  {
    return this->i_.get ();
  }

  ept::i_type& ept::
  i ()
  {
    return this->i_.get ();
  }

  void ept::
  i (const i_type& x)
  {
    this->i_.set (x);
  }

  void ept::
  i (::std::auto_ptr< i_type > x)
  {
    this->i_.set (x);
  }

  const ept::equiv_text_optional& ept::
  equiv_text () const
  {
    return this->equiv_text_;
  }

  ept::equiv_text_optional& ept::
  equiv_text ()
  {
    return this->equiv_text_;
  }

  void ept::
  equiv_text (const equiv_text_type& x)
  {
    this->equiv_text_.set (x);
  }

  void ept::
  equiv_text (const equiv_text_optional& x)
  {
    this->equiv_text_ = x;
  }

  void ept::
  equiv_text (::std::auto_ptr< equiv_text_type > x)
  {
    this->equiv_text_.set (x);
  }


  // g
  // 

  const g::xid_type& g::
  xid () const
  {
    return this->xid_.get ();
  }

  g::xid_type& g::
  xid ()
  {
    return this->xid_.get ();
  }

  void g::
  xid (const xid_type& x)
  {
    this->xid_.set (x);
  }

  void g::
  xid (::std::auto_ptr< xid_type > x)
  {
    this->xid_.set (x);
  }

  const g::type_type& g::
  type () const
  {
    return this->type_.get ();
  }

  g::type_type& g::
  type ()
  {
    return this->type_.get ();
  }

  void g::
  type (const type_type& x)
  {
    this->type_.set (x);
  }

  void g::
  type (::std::auto_ptr< type_type > x)
  {
    this->type_.set (x);
  }

  const g::equiv_text_optional& g::
  equiv_text () const
  {
    return this->equiv_text_;
  }

  g::equiv_text_optional& g::
  equiv_text ()
  {
    return this->equiv_text_;
  }

  void g::
  equiv_text (const equiv_text_type& x)
  {
    this->equiv_text_.set (x);
  }

  void g::
  equiv_text (const equiv_text_optional& x)
  {
    this->equiv_text_ = x;
  }

  void g::
  equiv_text (::std::auto_ptr< equiv_text_type > x)
  {
    this->equiv_text_.set (x);
  }

  const g::x_optional& g::
  x () const
  {
    return this->x_;
  }

  g::x_optional& g::
  x ()
  {
    return this->x_;
  }

  void g::
  x (const x_type& x)
  {
    this->x_.set (x);
  }

  void g::
  x (const x_optional& x)
  {
    this->x_ = x;
  }

  void g::
  x (::std::auto_ptr< x_type > x)
  {
    this->x_.set (x);
  }


  // hi
  // 

  const hi::bpt_sequence& hi::
  bpt () const
  {
    return this->bpt_;
  }

  hi::bpt_sequence& hi::
  bpt ()
  {
    return this->bpt_;
  }

  void hi::
  bpt (const bpt_sequence& s)
  {
    this->bpt_ = s;
  }

  const hi::ept_sequence& hi::
  ept () const
  {
    return this->ept_;
  }

  hi::ept_sequence& hi::
  ept ()
  {
    return this->ept_;
  }

  void hi::
  ept (const ept_sequence& s)
  {
    this->ept_ = s;
  }

  const hi::ph_sequence& hi::
  ph () const
  {
    return this->ph_;
  }

  hi::ph_sequence& hi::
  ph ()
  {
    return this->ph_;
  }

  void hi::
  ph (const ph_sequence& s)
  {
    this->ph_ = s;
  }

  const hi::x_sequence& hi::
  x () const
  {
    return this->x_;
  }

  hi::x_sequence& hi::
  x ()
  {
    return this->x_;
  }

  void hi::
  x (const x_sequence& s)
  {
    this->x_ = s;
  }

  const hi::g_sequence& hi::
  g () const
  {
    return this->g_;
  }

  hi::g_sequence& hi::
  g ()
  {
    return this->g_;
  }

  void hi::
  g (const g_sequence& s)
  {
    this->g_ = s;
  }

  const hi::hi1_sequence& hi::
  hi1 () const
  {
    return this->hi1_;
  }

  hi::hi1_sequence& hi::
  hi1 ()
  {
    return this->hi1_;
  }

  void hi::
  hi1 (const hi1_sequence& s)
  {
    this->hi1_ = s;
  }

  const hi::x1_optional& hi::
  x1 () const
  {
    return this->x1_;
  }

  hi::x1_optional& hi::
  x1 ()
  {
    return this->x1_;
  }

  void hi::
  x1 (const x1_type& x)
  {
    this->x1_.set (x);
  }

  void hi::
  x1 (const x1_optional& x)
  {
    this->x1_ = x;
  }

  void hi::
  x1 (::std::auto_ptr< x1_type > x)
  {
    this->x1_.set (x);
  }

  const hi::type_type& hi::
  type () const
  {
    return this->type_.get ();
  }

  hi::type_type& hi::
  type ()
  {
    return this->type_.get ();
  }

  void hi::
  type (const type_type& x)
  {
    this->type_.set (x);
  }

  void hi::
  type (::std::auto_ptr< type_type > x)
  {
    this->type_.set (x);
  }

  const hi::comment_optional& hi::
  comment () const
  {
    return this->comment_;
  }

  hi::comment_optional& hi::
  comment ()
  {
    return this->comment_;
  }

  void hi::
  comment (const comment_type& x)
  {
    this->comment_.set (x);
  }

  void hi::
  comment (const comment_optional& x)
  {
    this->comment_ = x;
  }

  void hi::
  comment (::std::auto_ptr< comment_type > x)
  {
    this->comment_.set (x);
  }


  // ph
  // 

  const ph::sub_sequence& ph::
  sub () const
  {
    return this->sub_;
  }

  ph::sub_sequence& ph::
  sub ()
  {
    return this->sub_;
  }

  void ph::
  sub (const sub_sequence& s)
  {
    this->sub_ = s;
  }

  const ph::x_optional& ph::
  x () const
  {
    return this->x_;
  }

  ph::x_optional& ph::
  x ()
  {
    return this->x_;
  }

  void ph::
  x (const x_type& x)
  {
    this->x_.set (x);
  }

  void ph::
  x (const x_optional& x)
  {
    this->x_ = x;
  }

  void ph::
  x (::std::auto_ptr< x_type > x)
  {
    this->x_.set (x);
  }

  const ph::assoc_optional& ph::
  assoc () const
  {
    return this->assoc_;
  }

  ph::assoc_optional& ph::
  assoc ()
  {
    return this->assoc_;
  }

  void ph::
  assoc (const assoc_type& x)
  {
    this->assoc_.set (x);
  }

  void ph::
  assoc (const assoc_optional& x)
  {
    this->assoc_ = x;
  }

  void ph::
  assoc (::std::auto_ptr< assoc_type > x)
  {
    this->assoc_.set (x);
  }

  const ph::equiv_text_optional& ph::
  equiv_text () const
  {
    return this->equiv_text_;
  }

  ph::equiv_text_optional& ph::
  equiv_text ()
  {
    return this->equiv_text_;
  }

  void ph::
  equiv_text (const equiv_text_type& x)
  {
    this->equiv_text_.set (x);
  }

  void ph::
  equiv_text (const equiv_text_optional& x)
  {
    this->equiv_text_ = x;
  }

  void ph::
  equiv_text (::std::auto_ptr< equiv_text_type > x)
  {
    this->equiv_text_.set (x);
  }

  const ph::type_type& ph::
  type () const
  {
    return this->type_.get ();
  }

  ph::type_type& ph::
  type ()
  {
    return this->type_.get ();
  }

  void ph::
  type (const type_type& x)
  {
    this->type_.set (x);
  }

  void ph::
  type (::std::auto_ptr< type_type > x)
  {
    this->type_.set (x);
  }


  // sub
  // 

  const sub::bpt_sequence& sub::
  bpt () const
  {
    return this->bpt_;
  }

  sub::bpt_sequence& sub::
  bpt ()
  {
    return this->bpt_;
  }

  void sub::
  bpt (const bpt_sequence& s)
  {
    this->bpt_ = s;
  }

  const sub::ept_sequence& sub::
  ept () const
  {
    return this->ept_;
  }

  sub::ept_sequence& sub::
  ept ()
  {
    return this->ept_;
  }

  void sub::
  ept (const ept_sequence& s)
  {
    this->ept_ = s;
  }

  const sub::ph_sequence& sub::
  ph () const
  {
    return this->ph_;
  }

  sub::ph_sequence& sub::
  ph ()
  {
    return this->ph_;
  }

  void sub::
  ph (const ph_sequence& s)
  {
    this->ph_ = s;
  }

  const sub::hi_sequence& sub::
  hi () const
  {
    return this->hi_;
  }

  sub::hi_sequence& sub::
  hi ()
  {
    return this->hi_;
  }

  void sub::
  hi (const hi_sequence& s)
  {
    this->hi_ = s;
  }

  const sub::g_sequence& sub::
  g () const
  {
    return this->g_;
  }

  sub::g_sequence& sub::
  g ()
  {
    return this->g_;
  }

  void sub::
  g (const g_sequence& s)
  {
    this->g_ = s;
  }

  const sub::x_sequence& sub::
  x () const
  {
    return this->x_;
  }

  sub::x_sequence& sub::
  x ()
  {
    return this->x_;
  }

  void sub::
  x (const x_sequence& s)
  {
    this->x_ = s;
  }

  const sub::datatype_type& sub::
  datatype () const
  {
    return this->datatype_.get ();
  }

  sub::datatype_type& sub::
  datatype ()
  {
    return this->datatype_.get ();
  }

  void sub::
  datatype (const datatype_type& x)
  {
    this->datatype_.set (x);
  }

  void sub::
  datatype (::std::auto_ptr< datatype_type > x)
  {
    this->datatype_.set (x);
  }

  const sub::datatype_type& sub::
  datatype_default_value ()
  {
    return datatype_default_value_;
  }

  const sub::type_type& sub::
  type () const
  {
    return this->type_.get ();
  }

  sub::type_type& sub::
  type ()
  {
    return this->type_.get ();
  }

  void sub::
  type (const type_type& x)
  {
    this->type_.set (x);
  }

  void sub::
  type (::std::auto_ptr< type_type > x)
  {
    this->type_.set (x);
  }

  const sub::x1_optional& sub::
  x1 () const
  {
    return this->x1_;
  }

  sub::x1_optional& sub::
  x1 ()
  {
    return this->x1_;
  }

  void sub::
  x1 (const x1_type& x)
  {
    this->x1_.set (x);
  }

  void sub::
  x1 (const x1_optional& x)
  {
    this->x1_ = x;
  }

  void sub::
  x1 (::std::auto_ptr< x1_type > x)
  {
    this->x1_.set (x);
  }


  // x
  // 

  const x::xid_type& x::
  xid () const
  {
    return this->xid_.get ();
  }

  x::xid_type& x::
  xid ()
  {
    return this->xid_.get ();
  }

  void x::
  xid (const xid_type& x)
  {
    this->xid_.set (x);
  }

  void x::
  xid (::std::auto_ptr< xid_type > x)
  {
    this->xid_.set (x);
  }

  const x::equiv_text_optional& x::
  equiv_text () const
  {
    return this->equiv_text_;
  }

  x::equiv_text_optional& x::
  equiv_text ()
  {
    return this->equiv_text_;
  }

  void x::
  equiv_text (const equiv_text_type& x)
  {
    this->equiv_text_.set (x);
  }

  void x::
  equiv_text (const equiv_text_optional& x)
  {
    this->equiv_text_ = x;
  }

  void x::
  equiv_text (::std::auto_ptr< equiv_text_type > x)
  {
    this->equiv_text_.set (x);
  }

  const x::type_type& x::
  type () const
  {
    return this->type_.get ();
  }

  x::type_type& x::
  type ()
  {
    return this->type_.get ();
  }

  void x::
  type (const type_type& x)
  {
    this->type_.set (x);
  }

  void x::
  type (::std::auto_ptr< type_type > x)
  {
    this->type_.set (x);
  }

  const x::x1_optional& x::
  x1 () const
  {
    return this->x1_;
  }

  x::x1_optional& x::
  x1 ()
  {
    return this->x1_;
  }

  void x::
  x1 (const x1_type& x)
  {
    this->x1_.set (x);
  }

  void x::
  x1 (const x1_optional& x)
  {
    this->x1_ = x;
  }

  void x::
  x1 (::std::auto_ptr< x1_type > x)
  {
    this->x1_.set (x);
  }


  // version
  // 

  version::
  version (value v)
  : ::xml_schema::string (_xsd_version_literals_[v])
  {
  }

  version::
  version (const char* v)
  : ::xml_schema::string (v)
  {
  }

  version::
  version (const ::std::string& v)
  : ::xml_schema::string (v)
  {
  }

  version::
  version (const ::xml_schema::string& v)
  : ::xml_schema::string (v)
  {
  }

  version::
  version (const version& v,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::string (v, f, c)
  {
  }

  version& version::
  operator= (value v)
  {
    static_cast< ::xml_schema::string& > (*this) = 
    ::xml_schema::string (_xsd_version_literals_[v]);

    return *this;
  }


  // context_type1
  //

  context_type1::
  context_type1 (const char* s)
  : ::xml_schema::string (s)
  {
  }

  context_type1::
  context_type1 (const ::std::string& s)
  : ::xml_schema::string (s)
  {
  }

  context_type1::
  context_type1 (const context_type1& o,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xml_schema::string (o, f, c)
  {
  }

  // datatype1
  //

  datatype1::
  datatype1 (const char* s)
  : ::xml_schema::string (s)
  {
  }

  datatype1::
  datatype1 (const ::std::string& s)
  : ::xml_schema::string (s)
  {
  }

  datatype1::
  datatype1 (const datatype1& o,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::xml_schema::string (o, f, c)
  {
  }

  // type
  //

  type::
  type (const char* s)
  : ::xml_schema::string (s)
  {
  }

  type::
  type (const ::std::string& s)
  : ::xml_schema::string (s)
  {
  }

  type::
  type (const type& o,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
  : ::xml_schema::string (o, f, c)
  {
  }

  // g_order
  // 


  // i
  // 


  // x1
  // 


  // type1
  //

  type1::
  type1 (const char* s)
  : ::xml_schema::string (s)
  {
  }

  type1::
  type1 (const ::std::string& s)
  : ::xml_schema::string (s)
  {
  }

  type1::
  type1 (const type1& o,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
  : ::xml_schema::string (o, f, c)
  {
  }

  // i1
  // 


  // type2
  //

  type2::
  type2 (const char* s)
  : ::xml_schema::string (s)
  {
  }

  type2::
  type2 (const ::std::string& s)
  : ::xml_schema::string (s)
  {
  }

  type2::
  type2 (const type2& o,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
  : ::xml_schema::string (o, f, c)
  {
  }

  // x2
  // 


  // x3
  // 


  // type3
  //

  type3::
  type3 (const char* s)
  : ::xml_schema::string (s)
  {
  }

  type3::
  type3 (const ::std::string& s)
  : ::xml_schema::string (s)
  {
  }

  type3::
  type3 (const type3& o,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
  : ::xml_schema::string (o, f, c)
  {
  }

  // x4
  // 


  // type4
  //

  type4::
  type4 (const char* s)
  : ::xml_schema::string (s)
  {
  }

  type4::
  type4 (const ::std::string& s)
  : ::xml_schema::string (s)
  {
  }

  type4::
  type4 (const type4& o,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
  : ::xml_schema::string (o, f, c)
  {
  }

  // type5
  //

  type5::
  type5 (const char* s)
  : ::xml_schema::string (s)
  {
  }

  type5::
  type5 (const ::std::string& s)
  : ::xml_schema::string (s)
  {
  }

  type5::
  type5 (const type5& o,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
  : ::xml_schema::string (o, f, c)
  {
  }

  // x5
  // 


  // type6
  //

  type6::
  type6 (const char* s)
  : ::xml_schema::string (s)
  {
  }

  type6::
  type6 (const ::std::string& s)
  : ::xml_schema::string (s)
  {
  }

  type6::
  type6 (const type6& o,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
  : ::xml_schema::string (o, f, c)
  {
  }

  // x6
  // 
}

#include <xsd/cxx/xml/dom/parsing-source.hxx>

namespace tmx20
{
  // segtypes
  //

  segtypes::
  segtypes (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::token (e, f, c)
  {
    _xsd_segtypes_convert ();
  }

  segtypes::
  segtypes (const ::xercesc::DOMAttr& a,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::token (a, f, c)
  {
    _xsd_segtypes_convert ();
  }

  segtypes::
  segtypes (const ::std::string& s,
            const ::xercesc::DOMElement* e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::token (s, e, f, c)
  {
    _xsd_segtypes_convert ();
  }

  segtypes* segtypes::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class segtypes (*this, f, c);
  }

  segtypes::value segtypes::
  _xsd_segtypes_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_segtypes_literals_);
    const value* i (::std::lower_bound (
                      _xsd_segtypes_indexes_,
                      _xsd_segtypes_indexes_ + 4,
                      *this,
                      c));

    if (i == _xsd_segtypes_indexes_ + 4 || _xsd_segtypes_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const segtypes::
  _xsd_segtypes_literals_[4] =
  {
    "block",
    "paragraph",
    "sentence",
    "phrase"
  };

  const segtypes::value segtypes::
  _xsd_segtypes_indexes_[4] =
  {
    ::tmx20::segtypes::block,
    ::tmx20::segtypes::paragraph,
    ::tmx20::segtypes::phrase,
    ::tmx20::segtypes::sentence
  };

  // space
  //

  space::
  space (const ::xercesc::DOMElement& e,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
  : ::xml_schema::token (e, f, c)
  {
    _xsd_space_convert ();
  }

  space::
  space (const ::xercesc::DOMAttr& a,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
  : ::xml_schema::token (a, f, c)
  {
    _xsd_space_convert ();
  }

  space::
  space (const ::std::string& s,
         const ::xercesc::DOMElement* e,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
  : ::xml_schema::token (s, e, f, c)
  {
    _xsd_space_convert ();
  }

  space* space::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class space (*this, f, c);
  }

  space::value space::
  _xsd_space_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_space_literals_);
    const value* i (::std::lower_bound (
                      _xsd_space_indexes_,
                      _xsd_space_indexes_ + 2,
                      *this,
                      c));

    if (i == _xsd_space_indexes_ + 2 || _xsd_space_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const space::
  _xsd_space_literals_[2] =
  {
    "default",
    "preserve"
  };

  const space::value space::
  _xsd_space_indexes_[2] =
  {
    ::tmx20::space::default_,
    ::tmx20::space::preserve
  };

  // assoc_type
  //

  assoc_type::
  assoc_type (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::token (e, f, c)
  {
    _xsd_assoc_type_convert ();
  }

  assoc_type::
  assoc_type (const ::xercesc::DOMAttr& a,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::token (a, f, c)
  {
    _xsd_assoc_type_convert ();
  }

  assoc_type::
  assoc_type (const ::std::string& s,
              const ::xercesc::DOMElement* e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::token (s, e, f, c)
  {
    _xsd_assoc_type_convert ();
  }

  assoc_type* assoc_type::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class assoc_type (*this, f, c);
  }

  assoc_type::value assoc_type::
  _xsd_assoc_type_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_assoc_type_literals_);
    const value* i (::std::lower_bound (
                      _xsd_assoc_type_indexes_,
                      _xsd_assoc_type_indexes_ + 3,
                      *this,
                      c));

    if (i == _xsd_assoc_type_indexes_ + 3 || _xsd_assoc_type_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const assoc_type::
  _xsd_assoc_type_literals_[3] =
  {
    "p",
    "f",
    "b"
  };

  const assoc_type::value assoc_type::
  _xsd_assoc_type_indexes_[3] =
  {
    ::tmx20::assoc_type::b,
    ::tmx20::assoc_type::f,
    ::tmx20::assoc_type::p
  };

  // datatype
  //

  datatype::
  datatype (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::token (e, f, c)
  {
    _xsd_datatype_convert ();
  }

  datatype::
  datatype (const ::xercesc::DOMAttr& a,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::token (a, f, c)
  {
    _xsd_datatype_convert ();
  }

  datatype::
  datatype (const ::std::string& s,
            const ::xercesc::DOMElement* e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::token (s, e, f, c)
  {
    _xsd_datatype_convert ();
  }

  datatype* datatype::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class datatype (*this, f, c);
  }

  datatype::value datatype::
  _xsd_datatype_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_datatype_literals_);
    const value* i (::std::lower_bound (
                      _xsd_datatype_indexes_,
                      _xsd_datatype_indexes_ + 29,
                      *this,
                      c));

    if (i == _xsd_datatype_indexes_ + 29 || _xsd_datatype_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const datatype::
  _xsd_datatype_literals_[29] =
  {
    "unknown",
    "undefined",
    "alptext",
    "cdf",
    "cmx",
    "cpp",
    "hptag",
    "html",
    "interleaf",
    "ipf",
    "java",
    "javascript",
    "lisp",
    "mif",
    "opentag",
    "pascal",
    "plaintext",
    "pm",
    "resx",
    "rtf",
    "sgml",
    "stf-f",
    "stf-i",
    "transit",
    "vbscript",
    "winres",
    "xliff",
    "xml",
    "xptag"
  };

  const datatype::value datatype::
  _xsd_datatype_indexes_[29] =
  {
    ::tmx20::datatype::alptext,
    ::tmx20::datatype::cdf,
    ::tmx20::datatype::cmx,
    ::tmx20::datatype::cpp,
    ::tmx20::datatype::hptag,
    ::tmx20::datatype::html,
    ::tmx20::datatype::interleaf,
    ::tmx20::datatype::ipf,
    ::tmx20::datatype::java,
    ::tmx20::datatype::javascript,
    ::tmx20::datatype::lisp,
    ::tmx20::datatype::mif,
    ::tmx20::datatype::opentag,
    ::tmx20::datatype::pascal,
    ::tmx20::datatype::plaintext,
    ::tmx20::datatype::pm,
    ::tmx20::datatype::resx,
    ::tmx20::datatype::rtf,
    ::tmx20::datatype::sgml,
    ::tmx20::datatype::stf_f,
    ::tmx20::datatype::stf_i,
    ::tmx20::datatype::transit,
    ::tmx20::datatype::undefined,
    ::tmx20::datatype::unknown,
    ::tmx20::datatype::vbscript,
    ::tmx20::datatype::winres,
    ::tmx20::datatype::xliff,
    ::tmx20::datatype::xml,
    ::tmx20::datatype::xptag
  };

  // paired_type
  //

  paired_type::
  paired_type (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xml_schema::token (e, f, c)
  {
    _xsd_paired_type_convert ();
  }

  paired_type::
  paired_type (const ::xercesc::DOMAttr& a,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xml_schema::token (a, f, c)
  {
    _xsd_paired_type_convert ();
  }

  paired_type::
  paired_type (const ::std::string& s,
               const ::xercesc::DOMElement* e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xml_schema::token (s, e, f, c)
  {
    _xsd_paired_type_convert ();
  }

  paired_type* paired_type::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class paired_type (*this, f, c);
  }

  paired_type::value paired_type::
  _xsd_paired_type_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_paired_type_literals_);
    const value* i (::std::lower_bound (
                      _xsd_paired_type_indexes_,
                      _xsd_paired_type_indexes_ + 11,
                      *this,
                      c));

    if (i == _xsd_paired_type_indexes_ + 11 || _xsd_paired_type_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const paired_type::
  _xsd_paired_type_literals_[11] =
  {
    "bold",
    "color",
    "dulined",
    "font",
    "italic",
    "link",
    "scap",
    "struct",
    "ulined",
    "xliff-bpt",
    "xliff-g"
  };

  const paired_type::value paired_type::
  _xsd_paired_type_indexes_[11] =
  {
    ::tmx20::paired_type::bold,
    ::tmx20::paired_type::color,
    ::tmx20::paired_type::dulined,
    ::tmx20::paired_type::font,
    ::tmx20::paired_type::italic,
    ::tmx20::paired_type::link,
    ::tmx20::paired_type::scap,
    ::tmx20::paired_type::struct_,
    ::tmx20::paired_type::ulined,
    ::tmx20::paired_type::xliff_bpt,
    ::tmx20::paired_type::xliff_g
  };

  // placeholder_type
  //

  placeholder_type::
  placeholder_type (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
  : ::xml_schema::token (e, f, c)
  {
    _xsd_placeholder_type_convert ();
  }

  placeholder_type::
  placeholder_type (const ::xercesc::DOMAttr& a,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
  : ::xml_schema::token (a, f, c)
  {
    _xsd_placeholder_type_convert ();
  }

  placeholder_type::
  placeholder_type (const ::std::string& s,
                    const ::xercesc::DOMElement* e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
  : ::xml_schema::token (s, e, f, c)
  {
    _xsd_placeholder_type_convert ();
  }

  placeholder_type* placeholder_type::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class placeholder_type (*this, f, c);
  }

  placeholder_type::value placeholder_type::
  _xsd_placeholder_type_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_placeholder_type_literals_);
    const value* i (::std::lower_bound (
                      _xsd_placeholder_type_indexes_,
                      _xsd_placeholder_type_indexes_ + 16,
                      *this,
                      c));

    if (i == _xsd_placeholder_type_indexes_ + 16 || _xsd_placeholder_type_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const placeholder_type::
  _xsd_placeholder_type_literals_[16] =
  {
    "index",
    "date",
    "time",
    "fnote",
    "enote",
    "alt",
    "image",
    "pb",
    "lb",
    "cb",
    "inset",
    "xliff-bx",
    "xliff-ex",
    "xliff-it",
    "xliff-ph",
    "xliff-x"
  };

  const placeholder_type::value placeholder_type::
  _xsd_placeholder_type_indexes_[16] =
  {
    ::tmx20::placeholder_type::alt,
    ::tmx20::placeholder_type::cb,
    ::tmx20::placeholder_type::date,
    ::tmx20::placeholder_type::enote,
    ::tmx20::placeholder_type::fnote,
    ::tmx20::placeholder_type::image,
    ::tmx20::placeholder_type::index,
    ::tmx20::placeholder_type::inset,
    ::tmx20::placeholder_type::lb,
    ::tmx20::placeholder_type::pb,
    ::tmx20::placeholder_type::time,
    ::tmx20::placeholder_type::xliff_bx,
    ::tmx20::placeholder_type::xliff_ex,
    ::tmx20::placeholder_type::xliff_it,
    ::tmx20::placeholder_type::xliff_ph,
    ::tmx20::placeholder_type::xliff_x
  };

  // term_type
  //

  term_type::
  term_type (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::xml_schema::token (e, f, c)
  {
    _xsd_term_type_convert ();
  }

  term_type::
  term_type (const ::xercesc::DOMAttr& a,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::xml_schema::token (a, f, c)
  {
    _xsd_term_type_convert ();
  }

  term_type::
  term_type (const ::std::string& s,
             const ::xercesc::DOMElement* e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::xml_schema::token (s, e, f, c)
  {
    _xsd_term_type_convert ();
  }

  term_type* term_type::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class term_type (*this, f, c);
  }

  term_type::value term_type::
  _xsd_term_type_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_term_type_literals_);
    const value* i (::std::lower_bound (
                      _xsd_term_type_indexes_,
                      _xsd_term_type_indexes_ + 36,
                      *this,
                      c));

    if (i == _xsd_term_type_indexes_ + 36 || _xsd_term_type_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const term_type::
  _xsd_term_type_literals_[36] =
  {
    "abbrev",
    "abbreviated-form",
    "abbreviation",
    "acronym",
    "appellation",
    "collocation",
    "common-name",
    "datetime",
    "equation",
    "expanded-form",
    "formula",
    "head-term",
    "initialism",
    "international-scientific-term",
    "internationalism",
    "logical-expression",
    "materials-management-unit",
    "name",
    "near-synonym",
    "part-number",
    "phrase",
    "phraseological-unit",
    "protected",
    "romanized-form",
    "set-phrase",
    "short-form",
    "sku",
    "standard-text",
    "symbol",
    "synonym",
    "synonymous-phrase",
    "term",
    "transcribed-form",
    "transliterated-form",
    "truncated-term",
    "variant"
  };

  const term_type::value term_type::
  _xsd_term_type_indexes_[36] =
  {
    ::tmx20::term_type::abbrev,
    ::tmx20::term_type::abbreviated_form,
    ::tmx20::term_type::abbreviation,
    ::tmx20::term_type::acronym,
    ::tmx20::term_type::appellation,
    ::tmx20::term_type::collocation,
    ::tmx20::term_type::common_name,
    ::tmx20::term_type::datetime,
    ::tmx20::term_type::equation,
    ::tmx20::term_type::expanded_form,
    ::tmx20::term_type::formula,
    ::tmx20::term_type::head_term,
    ::tmx20::term_type::initialism,
    ::tmx20::term_type::international_scientific_term,
    ::tmx20::term_type::internationalism,
    ::tmx20::term_type::logical_expression,
    ::tmx20::term_type::materials_management_unit,
    ::tmx20::term_type::name,
    ::tmx20::term_type::near_synonym,
    ::tmx20::term_type::part_number,
    ::tmx20::term_type::phrase,
    ::tmx20::term_type::phraseological_unit,
    ::tmx20::term_type::protected_,
    ::tmx20::term_type::romanized_form,
    ::tmx20::term_type::set_phrase,
    ::tmx20::term_type::short_form,
    ::tmx20::term_type::sku,
    ::tmx20::term_type::standard_text,
    ::tmx20::term_type::symbol,
    ::tmx20::term_type::synonym,
    ::tmx20::term_type::synonymous_phrase,
    ::tmx20::term_type::term,
    ::tmx20::term_type::transcribed_form,
    ::tmx20::term_type::transliterated_form,
    ::tmx20::term_type::truncated_term,
    ::tmx20::term_type::variant
  };

  // context_type
  //

  context_type::
  context_type (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
  : ::xml_schema::token (e, f, c)
  {
    _xsd_context_type_convert ();
  }

  context_type::
  context_type (const ::xercesc::DOMAttr& a,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
  : ::xml_schema::token (a, f, c)
  {
    _xsd_context_type_convert ();
  }

  context_type::
  context_type (const ::std::string& s,
                const ::xercesc::DOMElement* e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
  : ::xml_schema::token (s, e, f, c)
  {
    _xsd_context_type_convert ();
  }

  context_type* context_type::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class context_type (*this, f, c);
  }

  context_type::value context_type::
  _xsd_context_type_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_context_type_literals_);
    const value* i (::std::lower_bound (
                      _xsd_context_type_indexes_,
                      _xsd_context_type_indexes_ + 9,
                      *this,
                      c));

    if (i == _xsd_context_type_indexes_ + 9 || _xsd_context_type_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const context_type::
  _xsd_context_type_literals_[9] =
  {
    "database",
    "element",
    "elementtitle",
    "linenumber",
    "numparams",
    "paramnotes",
    "record",
    "recordtitle",
    "sourcefile"
  };

  const context_type::value context_type::
  _xsd_context_type_indexes_[9] =
  {
    ::tmx20::context_type::database,
    ::tmx20::context_type::element,
    ::tmx20::context_type::elementtitle,
    ::tmx20::context_type::linenumber,
    ::tmx20::context_type::numparams,
    ::tmx20::context_type::paramnotes,
    ::tmx20::context_type::record,
    ::tmx20::context_type::recordtitle,
    ::tmx20::context_type::sourcefile
  };

  // Custom
  //

  Custom::
  Custom ()
  : ::xml_schema::string ()
  {
  }

  Custom::
  Custom (const char* _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  Custom::
  Custom (const ::std::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  Custom::
  Custom (const ::xml_schema::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  Custom::
  Custom (const Custom& x,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
  : ::xml_schema::string (x, f, c)
  {
  }

  Custom::
  Custom (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
  : ::xml_schema::string (e, f, c)
  {
  }

  Custom::
  Custom (const ::xercesc::DOMAttr& a,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
  : ::xml_schema::string (a, f, c)
  {
  }

  Custom::
  Custom (const ::std::string& s,
          const ::xercesc::DOMElement* e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
  : ::xml_schema::string (s, e, f, c)
  {
  }

  Custom* Custom::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class Custom (*this, f, c);
  }

  Custom::
  ~Custom ()
  {
  }

  // tmx
  //

  tmx::
  tmx (const header_type& header,
       const body_type& body,
       const version_type& version)
  : ::xml_schema::type (),
    header_ (header, ::xml_schema::flags (), this),
    body_ (body, ::xml_schema::flags (), this),
    version_ (version, ::xml_schema::flags (), this)
  {
  }

  tmx::
  tmx (::std::auto_ptr< header_type >& header,
       ::std::auto_ptr< body_type >& body,
       const version_type& version)
  : ::xml_schema::type (),
    header_ (header, ::xml_schema::flags (), this),
    body_ (body, ::xml_schema::flags (), this),
    version_ (version, ::xml_schema::flags (), this)
  {
  }

  tmx::
  tmx (const tmx& x,
       ::xml_schema::flags f,
       ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    header_ (x.header_, f, this),
    body_ (x.body_, f, this),
    version_ (x.version_, f, this)
  {
  }

  tmx::
  tmx (const ::xercesc::DOMElement& e,
       ::xml_schema::flags f,
       ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    header_ (f, this),
    body_ (f, this),
    version_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
      this->parse (p, f);
    }
  }

  void tmx::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // header
      //
      if (n.name () == "header" && n.namespace_ () == "http://www.lisa.org/tmx20")
      {
        ::std::auto_ptr< header_type > r (
          header_traits::create (i, f, this));

        if (!header_.present ())
        {
          this->header_.set (r);
          continue;
        }
      }

      // body
      //
      if (n.name () == "body" && n.namespace_ () == "http://www.lisa.org/tmx20")
      {
        ::std::auto_ptr< body_type > r (
          body_traits::create (i, f, this));

        if (!body_.present ())
        {
          this->body_.set (r);
          continue;
        }
      }

      break;
    }

    if (!header_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "header",
        "http://www.lisa.org/tmx20");
    }

    if (!body_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "body",
        "http://www.lisa.org/tmx20");
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "version" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< version_type > r (
          version_traits::create (i, f, this));

        this->version_.set (r);
        continue;
      }
    }

    if (!version_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "version",
        "");
    }
  }

  tmx* tmx::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class tmx (*this, f, c);
  }

  tmx::
  ~tmx ()
  {
  }

  // body
  //

  body::
  body ()
  : ::xml_schema::type (),
    tu_ (::xml_schema::flags (), this)
  {
  }

  body::
  body (const body& x,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    tu_ (x.tu_, f, this)
  {
  }

  body::
  body (const ::xercesc::DOMElement& e,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    tu_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void body::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // tu
      //
      if (n.name () == "tu" && n.namespace_ () == "http://www.lisa.org/tmx20")
      {
        ::std::auto_ptr< tu_type > r (
          tu_traits::create (i, f, this));

        this->tu_.push_back (r);
        continue;
      }

      break;
    }
  }

  body* body::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class body (*this, f, c);
  }

  body::
  ~body ()
  {
  }

  // context
  //

  context::
  context (const context_type_type& context_type)
  : ::xml_schema::type (),
    context_type_ (context_type, ::xml_schema::flags (), this)
  {
  }

  context::
  context (const context& x,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    context_type_ (x.context_type_, f, this)
  {
  }

  context::
  context (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    context_type_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
      this->parse (p, f);
    }
  }

  void context::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "context-type" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< context_type_type > r (
          context_type_traits::create (i, f, this));

        this->context_type_.set (r);
        continue;
      }
    }

    if (!context_type_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "context-type",
        "");
    }
  }

  context* context::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class context (*this, f, c);
  }

  context::
  ~context ()
  {
  }

  // external_file
  //

  external_file::
  external_file (const href_type& href)
  : ::xml_schema::type (),
    href_ (href, ::xml_schema::flags (), this),
    crc_ (::xml_schema::flags (), this),
    uid_ (::xml_schema::flags (), this)
  {
  }

  external_file::
  external_file (const external_file& x,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    href_ (x.href_, f, this),
    crc_ (x.crc_, f, this),
    uid_ (x.uid_, f, this)
  {
  }

  external_file::
  external_file (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    href_ (f, this),
    crc_ (f, this),
    uid_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
      this->parse (p, f);
    }
  }

  void external_file::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "href" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< href_type > r (
          href_traits::create (i, f, this));

        this->href_.set (r);
        continue;
      }

      if (n.name () == "crc" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< crc_type > r (
          crc_traits::create (i, f, this));

        this->crc_.set (r);
        continue;
      }

      if (n.name () == "uid" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< uid_type > r (
          uid_traits::create (i, f, this));

        this->uid_.set (r);
        continue;
      }
    }

    if (!href_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "href",
        "");
    }
  }

  external_file* external_file::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class external_file (*this, f, c);
  }

  external_file::
  ~external_file ()
  {
  }

  // header
  //

  header::
  header (const creationtool_type& creationtool,
          const creationtoolversion_type& creationtoolversion,
          const segtype_type& segtype,
          const o_tmf_type& o_tmf,
          const adminlang_type& adminlang,
          const srclang_type& srclang,
          const datatype_type& datatype)
  : ::xml_schema::type (),
    note_ (::xml_schema::flags (), this),
    prop_ (::xml_schema::flags (), this),
    inline_data_ (::xml_schema::flags (), this),
    segmentation_ (::xml_schema::flags (), this),
    creationtool_ (creationtool, ::xml_schema::flags (), this),
    creationtoolversion_ (creationtoolversion, ::xml_schema::flags (), this),
    segtype_ (segtype, ::xml_schema::flags (), this),
    o_tmf_ (o_tmf, ::xml_schema::flags (), this),
    adminlang_ (adminlang, ::xml_schema::flags (), this),
    srclang_ (srclang, ::xml_schema::flags (), this),
    datatype_ (datatype, ::xml_schema::flags (), this),
    o_encoding_ (::xml_schema::flags (), this),
    creationdate_ (::xml_schema::flags (), this),
    creationid_ (::xml_schema::flags (), this),
    changedate_ (::xml_schema::flags (), this),
    changeid_ (::xml_schema::flags (), this)
  {
  }

  header::
  header (const header& x,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    note_ (x.note_, f, this),
    prop_ (x.prop_, f, this),
    inline_data_ (x.inline_data_, f, this),
    segmentation_ (x.segmentation_, f, this),
    creationtool_ (x.creationtool_, f, this),
    creationtoolversion_ (x.creationtoolversion_, f, this),
    segtype_ (x.segtype_, f, this),
    o_tmf_ (x.o_tmf_, f, this),
    adminlang_ (x.adminlang_, f, this),
    srclang_ (x.srclang_, f, this),
    datatype_ (x.datatype_, f, this),
    o_encoding_ (x.o_encoding_, f, this),
    creationdate_ (x.creationdate_, f, this),
    creationid_ (x.creationid_, f, this),
    changedate_ (x.changedate_, f, this),
    changeid_ (x.changeid_, f, this)
  {
  }

  header::
  header (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    note_ (f, this),
    prop_ (f, this),
    inline_data_ (f, this),
    segmentation_ (f, this),
    creationtool_ (f, this),
    creationtoolversion_ (f, this),
    segtype_ (f, this),
    o_tmf_ (f, this),
    adminlang_ (f, this),
    srclang_ (f, this),
    datatype_ (f, this),
    o_encoding_ (f, this),
    creationdate_ (f, this),
    creationid_ (f, this),
    changedate_ (f, this),
    changeid_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
      this->parse (p, f);
    }
  }

  void header::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // note
      //
      if (n.name () == "note" && n.namespace_ () == "http://www.lisa.org/tmx20")
      {
        ::std::auto_ptr< note_type > r (
          note_traits::create (i, f, this));

        this->note_.push_back (r);
        continue;
      }

      // prop
      //
      if (n.name () == "prop" && n.namespace_ () == "http://www.lisa.org/tmx20")
      {
        ::std::auto_ptr< prop_type > r (
          prop_traits::create (i, f, this));

        this->prop_.push_back (r);
        continue;
      }

      // inline-data
      //
      if (n.name () == "inline-data" && n.namespace_ () == "http://www.lisa.org/tmx20")
      {
        ::std::auto_ptr< inline_data_type > r (
          inline_data_traits::create (i, f, this));

        if (!this->inline_data_)
        {
          this->inline_data_.set (r);
          continue;
        }
      }

      // segmentation
      //
      if (n.name () == "segmentation" && n.namespace_ () == "http://www.lisa.org/tmx20")
      {
        ::std::auto_ptr< segmentation_type > r (
          segmentation_traits::create (i, f, this));

        if (!this->segmentation_)
        {
          this->segmentation_.set (r);
          continue;
        }
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "creationtool" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< creationtool_type > r (
          creationtool_traits::create (i, f, this));

        this->creationtool_.set (r);
        continue;
      }

      if (n.name () == "creationtoolversion" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< creationtoolversion_type > r (
          creationtoolversion_traits::create (i, f, this));

        this->creationtoolversion_.set (r);
        continue;
      }

      if (n.name () == "segtype" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< segtype_type > r (
          segtype_traits::create (i, f, this));

        this->segtype_.set (r);
        continue;
      }

      if (n.name () == "o-tmf" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< o_tmf_type > r (
          o_tmf_traits::create (i, f, this));

        this->o_tmf_.set (r);
        continue;
      }

      if (n.name () == "adminlang" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< adminlang_type > r (
          adminlang_traits::create (i, f, this));

        this->adminlang_.set (r);
        continue;
      }

      if (n.name () == "srclang" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< srclang_type > r (
          srclang_traits::create (i, f, this));

        this->srclang_.set (r);
        continue;
      }

      if (n.name () == "datatype" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< datatype_type > r (
          datatype_traits::create (i, f, this));

        this->datatype_.set (r);
        continue;
      }

      if (n.name () == "o-encoding" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< o_encoding_type > r (
          o_encoding_traits::create (i, f, this));

        this->o_encoding_.set (r);
        continue;
      }

      if (n.name () == "creationdate" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< creationdate_type > r (
          creationdate_traits::create (i, f, this));

        this->creationdate_.set (r);
        continue;
      }

      if (n.name () == "creationid" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< creationid_type > r (
          creationid_traits::create (i, f, this));

        this->creationid_.set (r);
        continue;
      }

      if (n.name () == "changedate" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< changedate_type > r (
          changedate_traits::create (i, f, this));

        this->changedate_.set (r);
        continue;
      }

      if (n.name () == "changeid" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< changeid_type > r (
          changeid_traits::create (i, f, this));

        this->changeid_.set (r);
        continue;
      }
    }

    if (!creationtool_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "creationtool",
        "");
    }

    if (!creationtoolversion_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "creationtoolversion",
        "");
    }

    if (!segtype_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "segtype",
        "");
    }

    if (!o_tmf_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "o-tmf",
        "");
    }

    if (!adminlang_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "adminlang",
        "");
    }

    if (!srclang_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "srclang",
        "");
    }

    if (!datatype_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "datatype",
        "");
    }
  }

  header* header::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class header (*this, f, c);
  }

  header::
  ~header ()
  {
  }

  // inline_data
  //

  inline_data::
  inline_data ()
  : ::xml_schema::type (),
    tag_ (::xml_schema::flags (), this)
  {
  }

  inline_data::
  inline_data (const inline_data& x,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    tag_ (x.tag_, f, this)
  {
  }

  inline_data::
  inline_data (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    tag_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void inline_data::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // tag
      //
      if (n.name () == "tag" && n.namespace_ () == "http://www.lisa.org/tmx20")
      {
        ::std::auto_ptr< tag_type > r (
          tag_traits::create (i, f, this));

        this->tag_.push_back (r);
        continue;
      }

      break;
    }
  }

  inline_data* inline_data::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class inline_data (*this, f, c);
  }

  inline_data::
  ~inline_data ()
  {
  }

  // internal_file
  //

  internal_file::
  internal_file ()
  : ::xml_schema::type ()
  {
  }

  internal_file::
  internal_file (const internal_file& x,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c)
  {
  }

  internal_file::
  internal_file (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void internal_file::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      break;
    }
  }

  internal_file* internal_file::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class internal_file (*this, f, c);
  }

  internal_file::
  ~internal_file ()
  {
  }

  // note
  //

  note::
  note ()
  : ::xml_schema::type (),
    o_encoding_ (::xml_schema::flags (), this),
    lang_ (::xml_schema::flags (), this),
    creationdate_ (::xml_schema::flags (), this),
    creationid_ (::xml_schema::flags (), this),
    changedate_ (::xml_schema::flags (), this),
    changeid_ (::xml_schema::flags (), this)
  {
  }

  note::
  note (const note& x,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    o_encoding_ (x.o_encoding_, f, this),
    lang_ (x.lang_, f, this),
    creationdate_ (x.creationdate_, f, this),
    creationid_ (x.creationid_, f, this),
    changedate_ (x.changedate_, f, this),
    changeid_ (x.changeid_, f, this)
  {
  }

  note::
  note (const ::xercesc::DOMElement& e,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    o_encoding_ (f, this),
    lang_ (f, this),
    creationdate_ (f, this),
    creationid_ (f, this),
    changedate_ (f, this),
    changeid_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
      this->parse (p, f);
    }
  }

  void note::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "o-encoding" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< o_encoding_type > r (
          o_encoding_traits::create (i, f, this));

        this->o_encoding_.set (r);
        continue;
      }

      if (n.name () == "lang" && n.namespace_ () == "http://www.w3.org/XML/1998/namespace")
      {
        ::std::auto_ptr< lang_type > r (
          lang_traits::create (i, f, this));

        this->lang_.set (r);
        continue;
      }

      if (n.name () == "creationdate" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< creationdate_type > r (
          creationdate_traits::create (i, f, this));

        this->creationdate_.set (r);
        continue;
      }

      if (n.name () == "creationid" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< creationid_type > r (
          creationid_traits::create (i, f, this));

        this->creationid_.set (r);
        continue;
      }

      if (n.name () == "changedate" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< changedate_type > r (
          changedate_traits::create (i, f, this));

        this->changedate_.set (r);
        continue;
      }

      if (n.name () == "changeid" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< changeid_type > r (
          changeid_traits::create (i, f, this));

        this->changeid_.set (r);
        continue;
      }
    }
  }

  note* note::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class note (*this, f, c);
  }

  note::
  ~note ()
  {
  }

  // prop
  //

  prop::
  prop (const name_type& name)
  : ::xml_schema::type (),
    name_ (name, ::xml_schema::flags (), this),
    lang_ (::xml_schema::flags (), this),
    o_encoding_ (::xml_schema::flags (), this)
  {
  }

  prop::
  prop (const prop& x,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    name_ (x.name_, f, this),
    lang_ (x.lang_, f, this),
    o_encoding_ (x.o_encoding_, f, this)
  {
  }

  prop::
  prop (const ::xercesc::DOMElement& e,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    name_ (f, this),
    lang_ (f, this),
    o_encoding_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
      this->parse (p, f);
    }
  }

  void prop::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "name" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< name_type > r (
          name_traits::create (i, f, this));

        this->name_.set (r);
        continue;
      }

      if (n.name () == "lang" && n.namespace_ () == "http://www.w3.org/XML/1998/namespace")
      {
        ::std::auto_ptr< lang_type > r (
          lang_traits::create (i, f, this));

        this->lang_.set (r);
        continue;
      }

      if (n.name () == "o-encoding" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< o_encoding_type > r (
          o_encoding_traits::create (i, f, this));

        this->o_encoding_.set (r);
        continue;
      }
    }

    if (!name_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "name",
        "");
    }
  }

  prop* prop::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class prop (*this, f, c);
  }

  prop::
  ~prop ()
  {
  }

  // seg
  //

  const seg::space_type seg::space_default_value_ (
    ::std::string ("default"), 0, 0, 0);

  seg::
  seg ()
  : ::xml_schema::type (),
    bpt_ (::xml_schema::flags (), this),
    ept_ (::xml_schema::flags (), this),
    ph_ (::xml_schema::flags (), this),
    hi_ (::xml_schema::flags (), this),
    x_ (::xml_schema::flags (), this),
    g_ (::xml_schema::flags (), this),
    space_ (space_default_value (), ::xml_schema::flags (), this)
  {
  }

  seg::
  seg (const seg& x,
       ::xml_schema::flags f,
       ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    bpt_ (x.bpt_, f, this),
    ept_ (x.ept_, f, this),
    ph_ (x.ph_, f, this),
    hi_ (x.hi_, f, this),
    x_ (x.x_, f, this),
    g_ (x.g_, f, this),
    space_ (x.space_, f, this)
  {
  }

  seg::
  seg (const ::xercesc::DOMElement& e,
       ::xml_schema::flags f,
       ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    bpt_ (f, this),
    ept_ (f, this),
    ph_ (f, this),
    hi_ (f, this),
    x_ (f, this),
    g_ (f, this),
    space_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
      this->parse (p, f);
    }
  }

  void seg::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // bpt
      //
      if (n.name () == "bpt" && n.namespace_ () == "http://www.lisa.org/tmx20")
      {
        ::std::auto_ptr< bpt_type > r (
          bpt_traits::create (i, f, this));

        this->bpt_.push_back (r);
        continue;
      }

      // ept
      //
      if (n.name () == "ept" && n.namespace_ () == "http://www.lisa.org/tmx20")
      {
        ::std::auto_ptr< ept_type > r (
          ept_traits::create (i, f, this));

        this->ept_.push_back (r);
        continue;
      }

      // ph
      //
      if (n.name () == "ph" && n.namespace_ () == "http://www.lisa.org/tmx20")
      {
        ::std::auto_ptr< ph_type > r (
          ph_traits::create (i, f, this));

        this->ph_.push_back (r);
        continue;
      }

      // hi
      //
      if (n.name () == "hi" && n.namespace_ () == "http://www.lisa.org/tmx20")
      {
        ::std::auto_ptr< hi_type > r (
          hi_traits::create (i, f, this));

        this->hi_.push_back (r);
        continue;
      }

      // x
      //
      if (n.name () == "x" && n.namespace_ () == "http://www.lisa.org/tmx20")
      {
        ::std::auto_ptr< x_type > r (
          x_traits::create (i, f, this));

        this->x_.push_back (r);
        continue;
      }

      // g
      //
      if (n.name () == "g" && n.namespace_ () == "http://www.lisa.org/tmx20")
      {
        ::std::auto_ptr< g_type > r (
          g_traits::create (i, f, this));

        this->g_.push_back (r);
        continue;
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "space" && n.namespace_ () == "http://www.w3.org/XML/1998/namespace")
      {
        ::std::auto_ptr< space_type > r (
          space_traits::create (i, f, this));

        this->space_.set (r);
        continue;
      }
    }

    if (!space_.present ())
    {
      this->space_.set (space_default_value ());
    }
  }

  seg* seg::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class seg (*this, f, c);
  }

  seg::
  ~seg ()
  {
  }

  // segmentation
  //

  segmentation::
  segmentation ()
  : ::xml_schema::type (),
    internal_file_ (::xml_schema::flags (), this),
    external_file_ (::xml_schema::flags (), this)
  {
  }

  segmentation::
  segmentation (const segmentation& x,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    internal_file_ (x.internal_file_, f, this),
    external_file_ (x.external_file_, f, this)
  {
  }

  segmentation::
  segmentation (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    internal_file_ (f, this),
    external_file_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void segmentation::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // internal-file
      //
      if (n.name () == "internal-file" && n.namespace_ () == "http://www.lisa.org/tmx20")
      {
        ::std::auto_ptr< internal_file_type > r (
          internal_file_traits::create (i, f, this));

        if (!this->internal_file_)
        {
          this->internal_file_.set (r);
          continue;
        }
      }

      // external-file
      //
      if (n.name () == "external-file" && n.namespace_ () == "http://www.lisa.org/tmx20")
      {
        ::std::auto_ptr< external_file_type > r (
          external_file_traits::create (i, f, this));

        if (!this->external_file_)
        {
          this->external_file_.set (r);
          continue;
        }
      }

      break;
    }
  }

  segmentation* segmentation::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class segmentation (*this, f, c);
  }

  segmentation::
  ~segmentation ()
  {
  }

  // tag
  //

  tag::
  tag (const id_type& id,
       const type_type& type)
  : ::xml_schema::type (),
    id_ (id, ::xml_schema::flags (), this),
    endmrk_ (::xml_schema::flags (), this),
    type_ (type, ::xml_schema::flags (), this),
    o_encoding_ (::xml_schema::flags (), this)
  {
  }

  tag::
  tag (const tag& x,
       ::xml_schema::flags f,
       ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    id_ (x.id_, f, this),
    endmrk_ (x.endmrk_, f, this),
    type_ (x.type_, f, this),
    o_encoding_ (x.o_encoding_, f, this)
  {
  }

  tag::
  tag (const ::xercesc::DOMElement& e,
       ::xml_schema::flags f,
       ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    id_ (f, this),
    endmrk_ (f, this),
    type_ (f, this),
    o_encoding_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
      this->parse (p, f);
    }
  }

  void tag::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "id" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< id_type > r (
          id_traits::create (i, f, this));

        this->id_.set (r);
        continue;
      }

      if (n.name () == "endmrk" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< endmrk_type > r (
          endmrk_traits::create (i, f, this));

        this->endmrk_.set (r);
        continue;
      }

      if (n.name () == "type" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< type_type > r (
          type_traits::create (i, f, this));

        this->type_.set (r);
        continue;
      }

      if (n.name () == "o-encoding" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< o_encoding_type > r (
          o_encoding_traits::create (i, f, this));

        this->o_encoding_.set (r);
        continue;
      }
    }

    if (!id_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "id",
        "");
    }

    if (!type_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "type",
        "");
    }
  }

  tag* tag::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class tag (*this, f, c);
  }

  tag::
  ~tag ()
  {
  }

  // tu
  //

  const tu::datatype_type tu::datatype_default_value_ (
    ::std::string ("unknown"), 0, 0, 0);

  tu::
  tu ()
  : ::xml_schema::type (),
    note_ (::xml_schema::flags (), this),
    prop_ (::xml_schema::flags (), this),
    context_ (::xml_schema::flags (), this),
    tuv_ (::xml_schema::flags (), this),
    tuid_ (::xml_schema::flags (), this),
    o_encoding_ (::xml_schema::flags (), this),
    datatype_ (datatype_default_value (), ::xml_schema::flags (), this),
    usagecount_ (::xml_schema::flags (), this),
    lastusagedate_ (::xml_schema::flags (), this),
    creationtool_ (::xml_schema::flags (), this),
    creationtoolversion_ (::xml_schema::flags (), this),
    creationdate_ (::xml_schema::flags (), this),
    creationid_ (::xml_schema::flags (), this),
    changedate_ (::xml_schema::flags (), this),
    segtype_ (::xml_schema::flags (), this),
    changeid_ (::xml_schema::flags (), this),
    o_tmf_ (::xml_schema::flags (), this),
    srclang_ (::xml_schema::flags (), this),
    group_ (::xml_schema::flags (), this),
    g_order_ (::xml_schema::flags (), this)
  {
  }

  tu::
  tu (const tu& x,
      ::xml_schema::flags f,
      ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    note_ (x.note_, f, this),
    prop_ (x.prop_, f, this),
    context_ (x.context_, f, this),
    tuv_ (x.tuv_, f, this),
    tuid_ (x.tuid_, f, this),
    o_encoding_ (x.o_encoding_, f, this),
    datatype_ (x.datatype_, f, this),
    usagecount_ (x.usagecount_, f, this),
    lastusagedate_ (x.lastusagedate_, f, this),
    creationtool_ (x.creationtool_, f, this),
    creationtoolversion_ (x.creationtoolversion_, f, this),
    creationdate_ (x.creationdate_, f, this),
    creationid_ (x.creationid_, f, this),
    changedate_ (x.changedate_, f, this),
    segtype_ (x.segtype_, f, this),
    changeid_ (x.changeid_, f, this),
    o_tmf_ (x.o_tmf_, f, this),
    srclang_ (x.srclang_, f, this),
    group_ (x.group_, f, this),
    g_order_ (x.g_order_, f, this)
  {
  }

  tu::
  tu (const ::xercesc::DOMElement& e,
      ::xml_schema::flags f,
      ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    note_ (f, this),
    prop_ (f, this),
    context_ (f, this),
    tuv_ (f, this),
    tuid_ (f, this),
    o_encoding_ (f, this),
    datatype_ (f, this),
    usagecount_ (f, this),
    lastusagedate_ (f, this),
    creationtool_ (f, this),
    creationtoolversion_ (f, this),
    creationdate_ (f, this),
    creationid_ (f, this),
    changedate_ (f, this),
    segtype_ (f, this),
    changeid_ (f, this),
    o_tmf_ (f, this),
    srclang_ (f, this),
    group_ (f, this),
    g_order_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
      this->parse (p, f);
    }
  }

  void tu::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // note
      //
      if (n.name () == "note" && n.namespace_ () == "http://www.lisa.org/tmx20")
      {
        ::std::auto_ptr< note_type > r (
          note_traits::create (i, f, this));

        this->note_.push_back (r);
        continue;
      }

      // prop
      //
      if (n.name () == "prop" && n.namespace_ () == "http://www.lisa.org/tmx20")
      {
        ::std::auto_ptr< prop_type > r (
          prop_traits::create (i, f, this));

        this->prop_.push_back (r);
        continue;
      }

      // context
      //
      if (n.name () == "context" && n.namespace_ () == "http://www.lisa.org/tmx20")
      {
        ::std::auto_ptr< context_type > r (
          context_traits::create (i, f, this));

        this->context_.push_back (r);
        continue;
      }

      // tuv
      //
      if (n.name () == "tuv" && n.namespace_ () == "http://www.lisa.org/tmx20")
      {
        ::std::auto_ptr< tuv_type > r (
          tuv_traits::create (i, f, this));

        this->tuv_.push_back (r);
        continue;
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "tuid" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< tuid_type > r (
          tuid_traits::create (i, f, this));

        this->tuid_.set (r);
        continue;
      }

      if (n.name () == "o-encoding" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< o_encoding_type > r (
          o_encoding_traits::create (i, f, this));

        this->o_encoding_.set (r);
        continue;
      }

      if (n.name () == "datatype" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< datatype_type > r (
          datatype_traits::create (i, f, this));

        this->datatype_.set (r);
        continue;
      }

      if (n.name () == "usagecount" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< usagecount_type > r (
          usagecount_traits::create (i, f, this));

        this->usagecount_.set (r);
        continue;
      }

      if (n.name () == "lastusagedate" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< lastusagedate_type > r (
          lastusagedate_traits::create (i, f, this));

        this->lastusagedate_.set (r);
        continue;
      }

      if (n.name () == "creationtool" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< creationtool_type > r (
          creationtool_traits::create (i, f, this));

        this->creationtool_.set (r);
        continue;
      }

      if (n.name () == "creationtoolversion" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< creationtoolversion_type > r (
          creationtoolversion_traits::create (i, f, this));

        this->creationtoolversion_.set (r);
        continue;
      }

      if (n.name () == "creationdate" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< creationdate_type > r (
          creationdate_traits::create (i, f, this));

        this->creationdate_.set (r);
        continue;
      }

      if (n.name () == "creationid" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< creationid_type > r (
          creationid_traits::create (i, f, this));

        this->creationid_.set (r);
        continue;
      }

      if (n.name () == "changedate" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< changedate_type > r (
          changedate_traits::create (i, f, this));

        this->changedate_.set (r);
        continue;
      }

      if (n.name () == "segtype" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< segtype_type > r (
          segtype_traits::create (i, f, this));

        this->segtype_.set (r);
        continue;
      }

      if (n.name () == "changeid" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< changeid_type > r (
          changeid_traits::create (i, f, this));

        this->changeid_.set (r);
        continue;
      }

      if (n.name () == "o-tmf" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< o_tmf_type > r (
          o_tmf_traits::create (i, f, this));

        this->o_tmf_.set (r);
        continue;
      }

      if (n.name () == "srclang" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< srclang_type > r (
          srclang_traits::create (i, f, this));

        this->srclang_.set (r);
        continue;
      }

      if (n.name () == "group" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< group_type > r (
          group_traits::create (i, f, this));

        this->group_.set (r);
        continue;
      }

      if (n.name () == "g-order" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< g_order_type > r (
          g_order_traits::create (i, f, this));

        this->g_order_.set (r);
        continue;
      }
    }

    if (!datatype_.present ())
    {
      this->datatype_.set (datatype_default_value ());
    }
  }

  tu* tu::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class tu (*this, f, c);
  }

  tu::
  ~tu ()
  {
  }

  // tuv
  //

  const tuv::datatype_type tuv::datatype_default_value_ (
    ::std::string ("unknown"), 0, 0, 0);

  tuv::
  tuv (const seg_type& seg,
       const lang_type& lang)
  : ::xml_schema::type (),
    note_ (::xml_schema::flags (), this),
    prop_ (::xml_schema::flags (), this),
    seg_ (seg, ::xml_schema::flags (), this),
    lang_ (lang, ::xml_schema::flags (), this),
    o_encoding_ (::xml_schema::flags (), this),
    datatype_ (datatype_default_value (), ::xml_schema::flags (), this),
    usagecount_ (::xml_schema::flags (), this),
    lastusagedate_ (::xml_schema::flags (), this),
    creationtool_ (::xml_schema::flags (), this),
    creationtoolversion_ (::xml_schema::flags (), this),
    creationdate_ (::xml_schema::flags (), this),
    creationid_ (::xml_schema::flags (), this),
    changedate_ (::xml_schema::flags (), this),
    o_tmf_ (::xml_schema::flags (), this),
    changeid_ (::xml_schema::flags (), this)
  {
  }

  tuv::
  tuv (::std::auto_ptr< seg_type >& seg,
       const lang_type& lang)
  : ::xml_schema::type (),
    note_ (::xml_schema::flags (), this),
    prop_ (::xml_schema::flags (), this),
    seg_ (seg, ::xml_schema::flags (), this),
    lang_ (lang, ::xml_schema::flags (), this),
    o_encoding_ (::xml_schema::flags (), this),
    datatype_ (datatype_default_value (), ::xml_schema::flags (), this),
    usagecount_ (::xml_schema::flags (), this),
    lastusagedate_ (::xml_schema::flags (), this),
    creationtool_ (::xml_schema::flags (), this),
    creationtoolversion_ (::xml_schema::flags (), this),
    creationdate_ (::xml_schema::flags (), this),
    creationid_ (::xml_schema::flags (), this),
    changedate_ (::xml_schema::flags (), this),
    o_tmf_ (::xml_schema::flags (), this),
    changeid_ (::xml_schema::flags (), this)
  {
  }

  tuv::
  tuv (const tuv& x,
       ::xml_schema::flags f,
       ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    note_ (x.note_, f, this),
    prop_ (x.prop_, f, this),
    seg_ (x.seg_, f, this),
    lang_ (x.lang_, f, this),
    o_encoding_ (x.o_encoding_, f, this),
    datatype_ (x.datatype_, f, this),
    usagecount_ (x.usagecount_, f, this),
    lastusagedate_ (x.lastusagedate_, f, this),
    creationtool_ (x.creationtool_, f, this),
    creationtoolversion_ (x.creationtoolversion_, f, this),
    creationdate_ (x.creationdate_, f, this),
    creationid_ (x.creationid_, f, this),
    changedate_ (x.changedate_, f, this),
    o_tmf_ (x.o_tmf_, f, this),
    changeid_ (x.changeid_, f, this)
  {
  }

  tuv::
  tuv (const ::xercesc::DOMElement& e,
       ::xml_schema::flags f,
       ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    note_ (f, this),
    prop_ (f, this),
    seg_ (f, this),
    lang_ (f, this),
    o_encoding_ (f, this),
    datatype_ (f, this),
    usagecount_ (f, this),
    lastusagedate_ (f, this),
    creationtool_ (f, this),
    creationtoolversion_ (f, this),
    creationdate_ (f, this),
    creationid_ (f, this),
    changedate_ (f, this),
    o_tmf_ (f, this),
    changeid_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
      this->parse (p, f);
    }
  }

  void tuv::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // note
      //
      if (n.name () == "note" && n.namespace_ () == "http://www.lisa.org/tmx20")
      {
        ::std::auto_ptr< note_type > r (
          note_traits::create (i, f, this));

        this->note_.push_back (r);
        continue;
      }

      // prop
      //
      if (n.name () == "prop" && n.namespace_ () == "http://www.lisa.org/tmx20")
      {
        ::std::auto_ptr< prop_type > r (
          prop_traits::create (i, f, this));

        this->prop_.push_back (r);
        continue;
      }

      // seg
      //
      if (n.name () == "seg" && n.namespace_ () == "http://www.lisa.org/tmx20")
      {
        ::std::auto_ptr< seg_type > r (
          seg_traits::create (i, f, this));

        if (!seg_.present ())
        {
          this->seg_.set (r);
          continue;
        }
      }

      break;
    }

    if (!seg_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "seg",
        "http://www.lisa.org/tmx20");
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "lang" && n.namespace_ () == "http://www.w3.org/XML/1998/namespace")
      {
        ::std::auto_ptr< lang_type > r (
          lang_traits::create (i, f, this));

        this->lang_.set (r);
        continue;
      }

      if (n.name () == "o-encoding" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< o_encoding_type > r (
          o_encoding_traits::create (i, f, this));

        this->o_encoding_.set (r);
        continue;
      }

      if (n.name () == "datatype" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< datatype_type > r (
          datatype_traits::create (i, f, this));

        this->datatype_.set (r);
        continue;
      }

      if (n.name () == "usagecount" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< usagecount_type > r (
          usagecount_traits::create (i, f, this));

        this->usagecount_.set (r);
        continue;
      }

      if (n.name () == "lastusagedate" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< lastusagedate_type > r (
          lastusagedate_traits::create (i, f, this));

        this->lastusagedate_.set (r);
        continue;
      }

      if (n.name () == "creationtool" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< creationtool_type > r (
          creationtool_traits::create (i, f, this));

        this->creationtool_.set (r);
        continue;
      }

      if (n.name () == "creationtoolversion" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< creationtoolversion_type > r (
          creationtoolversion_traits::create (i, f, this));

        this->creationtoolversion_.set (r);
        continue;
      }

      if (n.name () == "creationdate" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< creationdate_type > r (
          creationdate_traits::create (i, f, this));

        this->creationdate_.set (r);
        continue;
      }

      if (n.name () == "creationid" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< creationid_type > r (
          creationid_traits::create (i, f, this));

        this->creationid_.set (r);
        continue;
      }

      if (n.name () == "changedate" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< changedate_type > r (
          changedate_traits::create (i, f, this));

        this->changedate_.set (r);
        continue;
      }

      if (n.name () == "o-tmf" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< o_tmf_type > r (
          o_tmf_traits::create (i, f, this));

        this->o_tmf_.set (r);
        continue;
      }

      if (n.name () == "changeid" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< changeid_type > r (
          changeid_traits::create (i, f, this));

        this->changeid_.set (r);
        continue;
      }
    }

    if (!lang_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "lang",
        "http://www.w3.org/XML/1998/namespace");
    }

    if (!datatype_.present ())
    {
      this->datatype_.set (datatype_default_value ());
    }
  }

  tuv* tuv::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class tuv (*this, f, c);
  }

  tuv::
  ~tuv ()
  {
  }

  // bpt
  //

  bpt::
  bpt (const i_type& i,
       const type_type& type)
  : ::xml_schema::type (),
    sub_ (::xml_schema::flags (), this),
    i_ (i, ::xml_schema::flags (), this),
    x_ (::xml_schema::flags (), this),
    equiv_text_ (::xml_schema::flags (), this),
    type_ (type, ::xml_schema::flags (), this)
  {
  }

  bpt::
  bpt (const bpt& x,
       ::xml_schema::flags f,
       ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    sub_ (x.sub_, f, this),
    i_ (x.i_, f, this),
    x_ (x.x_, f, this),
    equiv_text_ (x.equiv_text_, f, this),
    type_ (x.type_, f, this)
  {
  }

  bpt::
  bpt (const ::xercesc::DOMElement& e,
       ::xml_schema::flags f,
       ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    sub_ (f, this),
    i_ (f, this),
    x_ (f, this),
    equiv_text_ (f, this),
    type_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
      this->parse (p, f);
    }
  }

  void bpt::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // sub
      //
      if (n.name () == "sub" && n.namespace_ () == "http://www.lisa.org/tmx20")
      {
        ::std::auto_ptr< sub_type > r (
          sub_traits::create (i, f, this));

        this->sub_.push_back (r);
        continue;
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "i" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< i_type > r (
          i_traits::create (i, f, this));

        this->i_.set (r);
        continue;
      }

      if (n.name () == "x" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< x_type > r (
          x_traits::create (i, f, this));

        this->x_.set (r);
        continue;
      }

      if (n.name () == "equiv-text" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< equiv_text_type > r (
          equiv_text_traits::create (i, f, this));

        this->equiv_text_.set (r);
        continue;
      }

      if (n.name () == "type" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< type_type > r (
          type_traits::create (i, f, this));

        this->type_.set (r);
        continue;
      }
    }

    if (!i_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "i",
        "");
    }

    if (!type_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "type",
        "");
    }
  }

  bpt* bpt::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class bpt (*this, f, c);
  }

  bpt::
  ~bpt ()
  {
  }

  // ept
  //

  ept::
  ept (const i_type& i)
  : ::xml_schema::type (),
    sub_ (::xml_schema::flags (), this),
    i_ (i, ::xml_schema::flags (), this),
    equiv_text_ (::xml_schema::flags (), this)
  {
  }

  ept::
  ept (const ept& x,
       ::xml_schema::flags f,
       ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    sub_ (x.sub_, f, this),
    i_ (x.i_, f, this),
    equiv_text_ (x.equiv_text_, f, this)
  {
  }

  ept::
  ept (const ::xercesc::DOMElement& e,
       ::xml_schema::flags f,
       ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    sub_ (f, this),
    i_ (f, this),
    equiv_text_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
      this->parse (p, f);
    }
  }

  void ept::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // sub
      //
      if (n.name () == "sub" && n.namespace_ () == "http://www.lisa.org/tmx20")
      {
        ::std::auto_ptr< sub_type > r (
          sub_traits::create (i, f, this));

        this->sub_.push_back (r);
        continue;
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "i" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< i_type > r (
          i_traits::create (i, f, this));

        this->i_.set (r);
        continue;
      }

      if (n.name () == "equiv-text" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< equiv_text_type > r (
          equiv_text_traits::create (i, f, this));

        this->equiv_text_.set (r);
        continue;
      }
    }

    if (!i_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "i",
        "");
    }
  }

  ept* ept::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class ept (*this, f, c);
  }

  ept::
  ~ept ()
  {
  }

  // g
  //

  g::
  g (const xid_type& xid,
     const type_type& type)
  : ::xml_schema::type (),
    xid_ (xid, ::xml_schema::flags (), this),
    type_ (type, ::xml_schema::flags (), this),
    equiv_text_ (::xml_schema::flags (), this),
    x_ (::xml_schema::flags (), this)
  {
  }

  g::
  g (const g& x,
     ::xml_schema::flags f,
     ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    xid_ (x.xid_, f, this),
    type_ (x.type_, f, this),
    equiv_text_ (x.equiv_text_, f, this),
    x_ (x.x_, f, this)
  {
  }

  g::
  g (const ::xercesc::DOMElement& e,
     ::xml_schema::flags f,
     ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    xid_ (f, this),
    type_ (f, this),
    equiv_text_ (f, this),
    x_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
      this->parse (p, f);
    }
  }

  void g::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "xid" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< xid_type > r (
          xid_traits::create (i, f, this));

        this->xid_.set (r);
        continue;
      }

      if (n.name () == "type" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< type_type > r (
          type_traits::create (i, f, this));

        this->type_.set (r);
        continue;
      }

      if (n.name () == "equiv-text" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< equiv_text_type > r (
          equiv_text_traits::create (i, f, this));

        this->equiv_text_.set (r);
        continue;
      }

      if (n.name () == "x" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< x_type > r (
          x_traits::create (i, f, this));

        this->x_.set (r);
        continue;
      }
    }

    if (!xid_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "xid",
        "");
    }

    if (!type_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "type",
        "");
    }
  }

  g* g::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class g (*this, f, c);
  }

  g::
  ~g ()
  {
  }

  // hi
  //

  hi::
  hi (const type_type& type)
  : ::xml_schema::type (),
    bpt_ (::xml_schema::flags (), this),
    ept_ (::xml_schema::flags (), this),
    ph_ (::xml_schema::flags (), this),
    x_ (::xml_schema::flags (), this),
    g_ (::xml_schema::flags (), this),
    hi1_ (::xml_schema::flags (), this),
    x1_ (::xml_schema::flags (), this),
    type_ (type, ::xml_schema::flags (), this),
    comment_ (::xml_schema::flags (), this)
  {
  }

  hi::
  hi (const hi& x,
      ::xml_schema::flags f,
      ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    bpt_ (x.bpt_, f, this),
    ept_ (x.ept_, f, this),
    ph_ (x.ph_, f, this),
    x_ (x.x_, f, this),
    g_ (x.g_, f, this),
    hi1_ (x.hi1_, f, this),
    x1_ (x.x1_, f, this),
    type_ (x.type_, f, this),
    comment_ (x.comment_, f, this)
  {
  }

  hi::
  hi (const ::xercesc::DOMElement& e,
      ::xml_schema::flags f,
      ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    bpt_ (f, this),
    ept_ (f, this),
    ph_ (f, this),
    x_ (f, this),
    g_ (f, this),
    hi1_ (f, this),
    x1_ (f, this),
    type_ (f, this),
    comment_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
      this->parse (p, f);
    }
  }

  void hi::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // bpt
      //
      if (n.name () == "bpt" && n.namespace_ () == "http://www.lisa.org/tmx20")
      {
        ::std::auto_ptr< bpt_type > r (
          bpt_traits::create (i, f, this));

        this->bpt_.push_back (r);
        continue;
      }

      // ept
      //
      if (n.name () == "ept" && n.namespace_ () == "http://www.lisa.org/tmx20")
      {
        ::std::auto_ptr< ept_type > r (
          ept_traits::create (i, f, this));

        this->ept_.push_back (r);
        continue;
      }

      // ph
      //
      if (n.name () == "ph" && n.namespace_ () == "http://www.lisa.org/tmx20")
      {
        ::std::auto_ptr< ph_type > r (
          ph_traits::create (i, f, this));

        this->ph_.push_back (r);
        continue;
      }

      // x
      //
      if (n.name () == "x" && n.namespace_ () == "http://www.lisa.org/tmx20")
      {
        ::std::auto_ptr< x_type > r (
          x_traits::create (i, f, this));

        this->x_.push_back (r);
        continue;
      }

      // g
      //
      if (n.name () == "g" && n.namespace_ () == "http://www.lisa.org/tmx20")
      {
        ::std::auto_ptr< g_type > r (
          g_traits::create (i, f, this));

        this->g_.push_back (r);
        continue;
      }

      // hi
      //
      if (n.name () == "hi" && n.namespace_ () == "http://www.lisa.org/tmx20")
      {
        ::std::auto_ptr< hi1_type > r (
          hi1_traits::create (i, f, this));

        this->hi1_.push_back (r);
        continue;
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "x" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< x1_type > r (
          x1_traits::create (i, f, this));

        this->x1_.set (r);
        continue;
      }

      if (n.name () == "type" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< type_type > r (
          type_traits::create (i, f, this));

        this->type_.set (r);
        continue;
      }

      if (n.name () == "comment" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< comment_type > r (
          comment_traits::create (i, f, this));

        this->comment_.set (r);
        continue;
      }
    }

    if (!type_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "type",
        "");
    }
  }

  hi* hi::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class hi (*this, f, c);
  }

  hi::
  ~hi ()
  {
  }

  // ph
  //

  ph::
  ph (const type_type& type)
  : ::xml_schema::type (),
    sub_ (::xml_schema::flags (), this),
    x_ (::xml_schema::flags (), this),
    assoc_ (::xml_schema::flags (), this),
    equiv_text_ (::xml_schema::flags (), this),
    type_ (type, ::xml_schema::flags (), this)
  {
  }

  ph::
  ph (const ph& x,
      ::xml_schema::flags f,
      ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    sub_ (x.sub_, f, this),
    x_ (x.x_, f, this),
    assoc_ (x.assoc_, f, this),
    equiv_text_ (x.equiv_text_, f, this),
    type_ (x.type_, f, this)
  {
  }

  ph::
  ph (const ::xercesc::DOMElement& e,
      ::xml_schema::flags f,
      ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    sub_ (f, this),
    x_ (f, this),
    assoc_ (f, this),
    equiv_text_ (f, this),
    type_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
      this->parse (p, f);
    }
  }

  void ph::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // sub
      //
      if (n.name () == "sub" && n.namespace_ () == "http://www.lisa.org/tmx20")
      {
        ::std::auto_ptr< sub_type > r (
          sub_traits::create (i, f, this));

        this->sub_.push_back (r);
        continue;
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "x" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< x_type > r (
          x_traits::create (i, f, this));

        this->x_.set (r);
        continue;
      }

      if (n.name () == "assoc" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< assoc_type > r (
          assoc_traits::create (i, f, this));

        this->assoc_.set (r);
        continue;
      }

      if (n.name () == "equiv-text" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< equiv_text_type > r (
          equiv_text_traits::create (i, f, this));

        this->equiv_text_.set (r);
        continue;
      }

      if (n.name () == "type" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< type_type > r (
          type_traits::create (i, f, this));

        this->type_.set (r);
        continue;
      }
    }

    if (!type_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "type",
        "");
    }
  }

  ph* ph::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class ph (*this, f, c);
  }

  ph::
  ~ph ()
  {
  }

  // sub
  //

  const sub::datatype_type sub::datatype_default_value_ (
    ::std::string ("unknown"), 0, 0, 0);

  sub::
  sub (const type_type& type)
  : ::xml_schema::type (),
    bpt_ (::xml_schema::flags (), this),
    ept_ (::xml_schema::flags (), this),
    ph_ (::xml_schema::flags (), this),
    hi_ (::xml_schema::flags (), this),
    g_ (::xml_schema::flags (), this),
    x_ (::xml_schema::flags (), this),
    datatype_ (datatype_default_value (), ::xml_schema::flags (), this),
    type_ (type, ::xml_schema::flags (), this),
    x1_ (::xml_schema::flags (), this)
  {
  }

  sub::
  sub (const sub& x,
       ::xml_schema::flags f,
       ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    bpt_ (x.bpt_, f, this),
    ept_ (x.ept_, f, this),
    ph_ (x.ph_, f, this),
    hi_ (x.hi_, f, this),
    g_ (x.g_, f, this),
    x_ (x.x_, f, this),
    datatype_ (x.datatype_, f, this),
    type_ (x.type_, f, this),
    x1_ (x.x1_, f, this)
  {
  }

  sub::
  sub (const ::xercesc::DOMElement& e,
       ::xml_schema::flags f,
       ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    bpt_ (f, this),
    ept_ (f, this),
    ph_ (f, this),
    hi_ (f, this),
    g_ (f, this),
    x_ (f, this),
    datatype_ (f, this),
    type_ (f, this),
    x1_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
      this->parse (p, f);
    }
  }

  void sub::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // bpt
      //
      if (n.name () == "bpt" && n.namespace_ () == "http://www.lisa.org/tmx20")
      {
        ::std::auto_ptr< bpt_type > r (
          bpt_traits::create (i, f, this));

        this->bpt_.push_back (r);
        continue;
      }

      // ept
      //
      if (n.name () == "ept" && n.namespace_ () == "http://www.lisa.org/tmx20")
      {
        ::std::auto_ptr< ept_type > r (
          ept_traits::create (i, f, this));

        this->ept_.push_back (r);
        continue;
      }

      // ph
      //
      if (n.name () == "ph" && n.namespace_ () == "http://www.lisa.org/tmx20")
      {
        ::std::auto_ptr< ph_type > r (
          ph_traits::create (i, f, this));

        this->ph_.push_back (r);
        continue;
      }

      // hi
      //
      if (n.name () == "hi" && n.namespace_ () == "http://www.lisa.org/tmx20")
      {
        ::std::auto_ptr< hi_type > r (
          hi_traits::create (i, f, this));

        this->hi_.push_back (r);
        continue;
      }

      // g
      //
      if (n.name () == "g" && n.namespace_ () == "http://www.lisa.org/tmx20")
      {
        ::std::auto_ptr< g_type > r (
          g_traits::create (i, f, this));

        this->g_.push_back (r);
        continue;
      }

      // x
      //
      if (n.name () == "x" && n.namespace_ () == "http://www.lisa.org/tmx20")
      {
        ::std::auto_ptr< x_type > r (
          x_traits::create (i, f, this));

        this->x_.push_back (r);
        continue;
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "datatype" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< datatype_type > r (
          datatype_traits::create (i, f, this));

        this->datatype_.set (r);
        continue;
      }

      if (n.name () == "type" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< type_type > r (
          type_traits::create (i, f, this));

        this->type_.set (r);
        continue;
      }

      if (n.name () == "x" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< x1_type > r (
          x1_traits::create (i, f, this));

        this->x1_.set (r);
        continue;
      }
    }

    if (!datatype_.present ())
    {
      this->datatype_.set (datatype_default_value ());
    }

    if (!type_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "type",
        "");
    }
  }

  sub* sub::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class sub (*this, f, c);
  }

  sub::
  ~sub ()
  {
  }

  // x
  //

  x::
  x (const xid_type& xid,
     const type_type& type)
  : ::xml_schema::type (),
    xid_ (xid, ::xml_schema::flags (), this),
    equiv_text_ (::xml_schema::flags (), this),
    type_ (type, ::xml_schema::flags (), this),
    x1_ (::xml_schema::flags (), this)
  {
  }

  x::
  x (const x& x,
     ::xml_schema::flags f,
     ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    xid_ (x.xid_, f, this),
    equiv_text_ (x.equiv_text_, f, this),
    type_ (x.type_, f, this),
    x1_ (x.x1_, f, this)
  {
  }

  x::
  x (const ::xercesc::DOMElement& e,
     ::xml_schema::flags f,
     ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    xid_ (f, this),
    equiv_text_ (f, this),
    type_ (f, this),
    x1_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
      this->parse (p, f);
    }
  }

  void x::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "xid" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< xid_type > r (
          xid_traits::create (i, f, this));

        this->xid_.set (r);
        continue;
      }

      if (n.name () == "equiv-text" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< equiv_text_type > r (
          equiv_text_traits::create (i, f, this));

        this->equiv_text_.set (r);
        continue;
      }

      if (n.name () == "type" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< type_type > r (
          type_traits::create (i, f, this));

        this->type_.set (r);
        continue;
      }

      if (n.name () == "x" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< x1_type > r (
          x1_traits::create (i, f, this));

        this->x1_.set (r);
        continue;
      }
    }

    if (!xid_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "xid",
        "");
    }

    if (!type_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "type",
        "");
    }
  }

  x* x::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class x (*this, f, c);
  }

  x::
  ~x ()
  {
  }

  // version
  //

  version::
  version (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::string (e, f, c)
  {
    _xsd_version_convert ();
  }

  version::
  version (const ::xercesc::DOMAttr& a,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::string (a, f, c)
  {
    _xsd_version_convert ();
  }

  version::
  version (const ::std::string& s,
           const ::xercesc::DOMElement* e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::string (s, e, f, c)
  {
    _xsd_version_convert ();
  }

  version* version::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class version (*this, f, c);
  }

  version::value version::
  _xsd_version_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_version_literals_);
    const value* i (::std::lower_bound (
                      _xsd_version_indexes_,
                      _xsd_version_indexes_ + 1,
                      *this,
                      c));

    if (i == _xsd_version_indexes_ + 1 || _xsd_version_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const version::
  _xsd_version_literals_[1] =
  {
    "2.0"
  };

  const version::value version::
  _xsd_version_indexes_[1] =
  {
    ::tmx20::version::cxx_2_0
  };

  // context_type1
  //

  context_type1::
  context_type1 (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xml_schema::string (e, f, c)
  {
  }

  context_type1::
  context_type1 (const ::xercesc::DOMAttr& a,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xml_schema::string (a, f, c)
  {
  }

  context_type1::
  context_type1 (const ::std::string& s,
                 const ::xercesc::DOMElement* e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xml_schema::string (s, e, f, c)
  {
  }

  context_type1* context_type1::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class context_type1 (*this, f, c);
  }

  // datatype1
  //

  datatype1::
  datatype1 (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::xml_schema::string (e, f, c)
  {
  }

  datatype1::
  datatype1 (const ::xercesc::DOMAttr& a,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::xml_schema::string (a, f, c)
  {
  }

  datatype1::
  datatype1 (const ::std::string& s,
             const ::xercesc::DOMElement* e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::xml_schema::string (s, e, f, c)
  {
  }

  datatype1* datatype1::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class datatype1 (*this, f, c);
  }

  // type
  //

  type::
  type (const ::xercesc::DOMElement& e,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
  : ::xml_schema::string (e, f, c)
  {
  }

  type::
  type (const ::xercesc::DOMAttr& a,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
  : ::xml_schema::string (a, f, c)
  {
  }

  type::
  type (const ::std::string& s,
        const ::xercesc::DOMElement* e,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
  : ::xml_schema::string (s, e, f, c)
  {
  }

  type* type::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class type (*this, f, c);
  }

  // g_order
  //

  g_order::
  g_order (const ::xml_schema::integer& _xsd_integer_base)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::integer, char, ::xml_schema::simple_type > (_xsd_integer_base)
  {
  }

  g_order::
  g_order (const g_order& x,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::integer, char, ::xml_schema::simple_type > (x, f, c)
  {
  }

  g_order::
  g_order (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::integer, char, ::xml_schema::simple_type > (e, f, c)
  {
  }

  g_order::
  g_order (const ::xercesc::DOMAttr& a,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::integer, char, ::xml_schema::simple_type > (a, f, c)
  {
  }

  g_order::
  g_order (const ::std::string& s,
           const ::xercesc::DOMElement* e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::integer, char, ::xml_schema::simple_type > (s, e, f, c)
  {
  }

  g_order* g_order::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class g_order (*this, f, c);
  }

  g_order::
  ~g_order ()
  {
  }

  // i
  //

  i::
  i (const ::xml_schema::integer& _xsd_integer_base)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::integer, char, ::xml_schema::simple_type > (_xsd_integer_base)
  {
  }

  i::
  i (const i& x,
     ::xml_schema::flags f,
     ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::integer, char, ::xml_schema::simple_type > (x, f, c)
  {
  }

  i::
  i (const ::xercesc::DOMElement& e,
     ::xml_schema::flags f,
     ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::integer, char, ::xml_schema::simple_type > (e, f, c)
  {
  }

  i::
  i (const ::xercesc::DOMAttr& a,
     ::xml_schema::flags f,
     ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::integer, char, ::xml_schema::simple_type > (a, f, c)
  {
  }

  i::
  i (const ::std::string& s,
     const ::xercesc::DOMElement* e,
     ::xml_schema::flags f,
     ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::integer, char, ::xml_schema::simple_type > (s, e, f, c)
  {
  }

  i* i::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class i (*this, f, c);
  }

  i::
  ~i ()
  {
  }

  // x1
  //

  x1::
  x1 (const ::xml_schema::integer& _xsd_integer_base)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::integer, char, ::xml_schema::simple_type > (_xsd_integer_base)
  {
  }

  x1::
  x1 (const x1& x,
      ::xml_schema::flags f,
      ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::integer, char, ::xml_schema::simple_type > (x, f, c)
  {
  }

  x1::
  x1 (const ::xercesc::DOMElement& e,
      ::xml_schema::flags f,
      ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::integer, char, ::xml_schema::simple_type > (e, f, c)
  {
  }

  x1::
  x1 (const ::xercesc::DOMAttr& a,
      ::xml_schema::flags f,
      ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::integer, char, ::xml_schema::simple_type > (a, f, c)
  {
  }

  x1::
  x1 (const ::std::string& s,
      const ::xercesc::DOMElement* e,
      ::xml_schema::flags f,
      ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::integer, char, ::xml_schema::simple_type > (s, e, f, c)
  {
  }

  x1* x1::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class x1 (*this, f, c);
  }

  x1::
  ~x1 ()
  {
  }

  // type1
  //

  type1::
  type1 (const ::xercesc::DOMElement& e,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
  : ::xml_schema::string (e, f, c)
  {
  }

  type1::
  type1 (const ::xercesc::DOMAttr& a,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
  : ::xml_schema::string (a, f, c)
  {
  }

  type1::
  type1 (const ::std::string& s,
         const ::xercesc::DOMElement* e,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
  : ::xml_schema::string (s, e, f, c)
  {
  }

  type1* type1::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class type1 (*this, f, c);
  }

  // i1
  //

  i1::
  i1 (const ::xml_schema::integer& _xsd_integer_base)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::integer, char, ::xml_schema::simple_type > (_xsd_integer_base)
  {
  }

  i1::
  i1 (const i1& x,
      ::xml_schema::flags f,
      ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::integer, char, ::xml_schema::simple_type > (x, f, c)
  {
  }

  i1::
  i1 (const ::xercesc::DOMElement& e,
      ::xml_schema::flags f,
      ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::integer, char, ::xml_schema::simple_type > (e, f, c)
  {
  }

  i1::
  i1 (const ::xercesc::DOMAttr& a,
      ::xml_schema::flags f,
      ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::integer, char, ::xml_schema::simple_type > (a, f, c)
  {
  }

  i1::
  i1 (const ::std::string& s,
      const ::xercesc::DOMElement* e,
      ::xml_schema::flags f,
      ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::integer, char, ::xml_schema::simple_type > (s, e, f, c)
  {
  }

  i1* i1::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class i1 (*this, f, c);
  }

  i1::
  ~i1 ()
  {
  }

  // type2
  //

  type2::
  type2 (const ::xercesc::DOMElement& e,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
  : ::xml_schema::string (e, f, c)
  {
  }

  type2::
  type2 (const ::xercesc::DOMAttr& a,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
  : ::xml_schema::string (a, f, c)
  {
  }

  type2::
  type2 (const ::std::string& s,
         const ::xercesc::DOMElement* e,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
  : ::xml_schema::string (s, e, f, c)
  {
  }

  type2* type2::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class type2 (*this, f, c);
  }

  // x2
  //

  x2::
  x2 (const ::xml_schema::integer& _xsd_integer_base)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::integer, char, ::xml_schema::simple_type > (_xsd_integer_base)
  {
  }

  x2::
  x2 (const x2& x,
      ::xml_schema::flags f,
      ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::integer, char, ::xml_schema::simple_type > (x, f, c)
  {
  }

  x2::
  x2 (const ::xercesc::DOMElement& e,
      ::xml_schema::flags f,
      ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::integer, char, ::xml_schema::simple_type > (e, f, c)
  {
  }

  x2::
  x2 (const ::xercesc::DOMAttr& a,
      ::xml_schema::flags f,
      ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::integer, char, ::xml_schema::simple_type > (a, f, c)
  {
  }

  x2::
  x2 (const ::std::string& s,
      const ::xercesc::DOMElement* e,
      ::xml_schema::flags f,
      ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::integer, char, ::xml_schema::simple_type > (s, e, f, c)
  {
  }

  x2* x2::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class x2 (*this, f, c);
  }

  x2::
  ~x2 ()
  {
  }

  // x3
  //

  x3::
  x3 (const ::xml_schema::integer& _xsd_integer_base)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::integer, char, ::xml_schema::simple_type > (_xsd_integer_base)
  {
  }

  x3::
  x3 (const x3& x,
      ::xml_schema::flags f,
      ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::integer, char, ::xml_schema::simple_type > (x, f, c)
  {
  }

  x3::
  x3 (const ::xercesc::DOMElement& e,
      ::xml_schema::flags f,
      ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::integer, char, ::xml_schema::simple_type > (e, f, c)
  {
  }

  x3::
  x3 (const ::xercesc::DOMAttr& a,
      ::xml_schema::flags f,
      ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::integer, char, ::xml_schema::simple_type > (a, f, c)
  {
  }

  x3::
  x3 (const ::std::string& s,
      const ::xercesc::DOMElement* e,
      ::xml_schema::flags f,
      ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::integer, char, ::xml_schema::simple_type > (s, e, f, c)
  {
  }

  x3* x3::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class x3 (*this, f, c);
  }

  x3::
  ~x3 ()
  {
  }

  // type3
  //

  type3::
  type3 (const ::xercesc::DOMElement& e,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
  : ::xml_schema::string (e, f, c)
  {
  }

  type3::
  type3 (const ::xercesc::DOMAttr& a,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
  : ::xml_schema::string (a, f, c)
  {
  }

  type3::
  type3 (const ::std::string& s,
         const ::xercesc::DOMElement* e,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
  : ::xml_schema::string (s, e, f, c)
  {
  }

  type3* type3::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class type3 (*this, f, c);
  }

  // x4
  //

  x4::
  x4 (const ::xml_schema::integer& _xsd_integer_base)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::integer, char, ::xml_schema::simple_type > (_xsd_integer_base)
  {
  }

  x4::
  x4 (const x4& x,
      ::xml_schema::flags f,
      ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::integer, char, ::xml_schema::simple_type > (x, f, c)
  {
  }

  x4::
  x4 (const ::xercesc::DOMElement& e,
      ::xml_schema::flags f,
      ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::integer, char, ::xml_schema::simple_type > (e, f, c)
  {
  }

  x4::
  x4 (const ::xercesc::DOMAttr& a,
      ::xml_schema::flags f,
      ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::integer, char, ::xml_schema::simple_type > (a, f, c)
  {
  }

  x4::
  x4 (const ::std::string& s,
      const ::xercesc::DOMElement* e,
      ::xml_schema::flags f,
      ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::integer, char, ::xml_schema::simple_type > (s, e, f, c)
  {
  }

  x4* x4::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class x4 (*this, f, c);
  }

  x4::
  ~x4 ()
  {
  }

  // type4
  //

  type4::
  type4 (const ::xercesc::DOMElement& e,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
  : ::xml_schema::string (e, f, c)
  {
  }

  type4::
  type4 (const ::xercesc::DOMAttr& a,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
  : ::xml_schema::string (a, f, c)
  {
  }

  type4::
  type4 (const ::std::string& s,
         const ::xercesc::DOMElement* e,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
  : ::xml_schema::string (s, e, f, c)
  {
  }

  type4* type4::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class type4 (*this, f, c);
  }

  // type5
  //

  type5::
  type5 (const ::xercesc::DOMElement& e,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
  : ::xml_schema::string (e, f, c)
  {
  }

  type5::
  type5 (const ::xercesc::DOMAttr& a,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
  : ::xml_schema::string (a, f, c)
  {
  }

  type5::
  type5 (const ::std::string& s,
         const ::xercesc::DOMElement* e,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
  : ::xml_schema::string (s, e, f, c)
  {
  }

  type5* type5::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class type5 (*this, f, c);
  }

  // x5
  //

  x5::
  x5 (const ::xml_schema::integer& _xsd_integer_base)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::integer, char, ::xml_schema::simple_type > (_xsd_integer_base)
  {
  }

  x5::
  x5 (const x5& x,
      ::xml_schema::flags f,
      ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::integer, char, ::xml_schema::simple_type > (x, f, c)
  {
  }

  x5::
  x5 (const ::xercesc::DOMElement& e,
      ::xml_schema::flags f,
      ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::integer, char, ::xml_schema::simple_type > (e, f, c)
  {
  }

  x5::
  x5 (const ::xercesc::DOMAttr& a,
      ::xml_schema::flags f,
      ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::integer, char, ::xml_schema::simple_type > (a, f, c)
  {
  }

  x5::
  x5 (const ::std::string& s,
      const ::xercesc::DOMElement* e,
      ::xml_schema::flags f,
      ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::integer, char, ::xml_schema::simple_type > (s, e, f, c)
  {
  }

  x5* x5::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class x5 (*this, f, c);
  }

  x5::
  ~x5 ()
  {
  }

  // type6
  //

  type6::
  type6 (const ::xercesc::DOMElement& e,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
  : ::xml_schema::string (e, f, c)
  {
  }

  type6::
  type6 (const ::xercesc::DOMAttr& a,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
  : ::xml_schema::string (a, f, c)
  {
  }

  type6::
  type6 (const ::std::string& s,
         const ::xercesc::DOMElement* e,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
  : ::xml_schema::string (s, e, f, c)
  {
  }

  type6* type6::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class type6 (*this, f, c);
  }

  // x6
  //

  x6::
  x6 (const ::xml_schema::integer& _xsd_integer_base)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::integer, char, ::xml_schema::simple_type > (_xsd_integer_base)
  {
  }

  x6::
  x6 (const x6& x,
      ::xml_schema::flags f,
      ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::integer, char, ::xml_schema::simple_type > (x, f, c)
  {
  }

  x6::
  x6 (const ::xercesc::DOMElement& e,
      ::xml_schema::flags f,
      ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::integer, char, ::xml_schema::simple_type > (e, f, c)
  {
  }

  x6::
  x6 (const ::xercesc::DOMAttr& a,
      ::xml_schema::flags f,
      ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::integer, char, ::xml_schema::simple_type > (a, f, c)
  {
  }

  x6::
  x6 (const ::std::string& s,
      const ::xercesc::DOMElement* e,
      ::xml_schema::flags f,
      ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::integer, char, ::xml_schema::simple_type > (s, e, f, c)
  {
  }

  x6* x6::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class x6 (*this, f, c);
  }

  x6::
  ~x6 ()
  {
  }
}

#include <istream>
#include <xsd/cxx/xml/sax/std-input-source.hxx>
#include <xsd/cxx/tree/error-handler.hxx>

namespace tmx20
{
  ::std::auto_ptr< ::tmx20::tmx >
  tmx_ (const ::std::string& u,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    ::std::auto_ptr< ::tmx20::tmx > r (
      ::tmx20::tmx_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::tmx20::tmx >
  tmx_ (const ::std::string& u,
        ::xml_schema::error_handler& h,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::tmx20::tmx > r (
      ::tmx20::tmx_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::tmx20::tmx >
  tmx_ (const ::std::string& u,
        ::xercesc::DOMErrorHandler& h,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::tmx20::tmx > r (
      ::tmx20::tmx_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::tmx20::tmx >
  tmx_ (::std::istream& is,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::tmx20::tmx_ (isrc, f, p);
  }

  ::std::auto_ptr< ::tmx20::tmx >
  tmx_ (::std::istream& is,
        ::xml_schema::error_handler& h,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::tmx20::tmx_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::tmx20::tmx >
  tmx_ (::std::istream& is,
        ::xercesc::DOMErrorHandler& h,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::tmx20::tmx_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::tmx20::tmx >
  tmx_ (::std::istream& is,
        const ::std::string& sid,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::tmx20::tmx_ (isrc, f, p);
  }

  ::std::auto_ptr< ::tmx20::tmx >
  tmx_ (::std::istream& is,
        const ::std::string& sid,
        ::xml_schema::error_handler& h,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::tmx20::tmx_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::tmx20::tmx >
  tmx_ (::std::istream& is,
        const ::std::string& sid,
        ::xercesc::DOMErrorHandler& h,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::tmx20::tmx_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::tmx20::tmx >
  tmx_ (::xercesc::InputSource& i,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    ::std::auto_ptr< ::tmx20::tmx > r (
      ::tmx20::tmx_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::tmx20::tmx >
  tmx_ (::xercesc::InputSource& i,
        ::xml_schema::error_handler& h,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::tmx20::tmx > r (
      ::tmx20::tmx_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::tmx20::tmx >
  tmx_ (::xercesc::InputSource& i,
        ::xercesc::DOMErrorHandler& h,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::tmx20::tmx > r (
      ::tmx20::tmx_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::tmx20::tmx >
  tmx_ (const ::xercesc::DOMDocument& d,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
  {
    if (f & ::xml_schema::flags::keep_dom)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

      ::std::auto_ptr< ::tmx20::tmx > r (
        ::tmx20::tmx_ (
          c, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    const ::xercesc::DOMElement& e (*d.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "tmx" &&
        n.namespace_ () == "http://www.lisa.org/tmx20")
    {
      ::std::auto_ptr< ::tmx20::tmx > r (
        ::xsd::cxx::tree::traits< ::tmx20::tmx, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "tmx",
      "http://www.lisa.org/tmx20");
  }

  ::std::auto_ptr< ::tmx20::tmx >
  tmx_ (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
        ::xml_schema::flags f,
        const ::xml_schema::properties&)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::flags::keep_dom) &&
       !(f & ::xml_schema::flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "tmx" &&
        n.namespace_ () == "http://www.lisa.org/tmx20")
    {
      ::std::auto_ptr< ::tmx20::tmx > r (
        ::xsd::cxx::tree::traits< ::tmx20::tmx, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "tmx",
      "http://www.lisa.org/tmx20");
  }

  ::std::auto_ptr< ::tmx20::body >
  body_ (const ::std::string& u,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    ::std::auto_ptr< ::tmx20::body > r (
      ::tmx20::body_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::tmx20::body >
  body_ (const ::std::string& u,
         ::xml_schema::error_handler& h,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::tmx20::body > r (
      ::tmx20::body_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::tmx20::body >
  body_ (const ::std::string& u,
         ::xercesc::DOMErrorHandler& h,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::tmx20::body > r (
      ::tmx20::body_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::tmx20::body >
  body_ (::std::istream& is,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::tmx20::body_ (isrc, f, p);
  }

  ::std::auto_ptr< ::tmx20::body >
  body_ (::std::istream& is,
         ::xml_schema::error_handler& h,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::tmx20::body_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::tmx20::body >
  body_ (::std::istream& is,
         ::xercesc::DOMErrorHandler& h,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::tmx20::body_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::tmx20::body >
  body_ (::std::istream& is,
         const ::std::string& sid,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::tmx20::body_ (isrc, f, p);
  }

  ::std::auto_ptr< ::tmx20::body >
  body_ (::std::istream& is,
         const ::std::string& sid,
         ::xml_schema::error_handler& h,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::tmx20::body_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::tmx20::body >
  body_ (::std::istream& is,
         const ::std::string& sid,
         ::xercesc::DOMErrorHandler& h,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::tmx20::body_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::tmx20::body >
  body_ (::xercesc::InputSource& i,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    ::std::auto_ptr< ::tmx20::body > r (
      ::tmx20::body_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::tmx20::body >
  body_ (::xercesc::InputSource& i,
         ::xml_schema::error_handler& h,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::tmx20::body > r (
      ::tmx20::body_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::tmx20::body >
  body_ (::xercesc::InputSource& i,
         ::xercesc::DOMErrorHandler& h,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::tmx20::body > r (
      ::tmx20::body_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::tmx20::body >
  body_ (const ::xercesc::DOMDocument& d,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
  {
    if (f & ::xml_schema::flags::keep_dom)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

      ::std::auto_ptr< ::tmx20::body > r (
        ::tmx20::body_ (
          c, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    const ::xercesc::DOMElement& e (*d.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "body" &&
        n.namespace_ () == "http://www.lisa.org/tmx20")
    {
      ::std::auto_ptr< ::tmx20::body > r (
        ::xsd::cxx::tree::traits< ::tmx20::body, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "body",
      "http://www.lisa.org/tmx20");
  }

  ::std::auto_ptr< ::tmx20::body >
  body_ (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
         ::xml_schema::flags f,
         const ::xml_schema::properties&)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::flags::keep_dom) &&
       !(f & ::xml_schema::flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "body" &&
        n.namespace_ () == "http://www.lisa.org/tmx20")
    {
      ::std::auto_ptr< ::tmx20::body > r (
        ::xsd::cxx::tree::traits< ::tmx20::body, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "body",
      "http://www.lisa.org/tmx20");
  }

  ::std::auto_ptr< ::tmx20::context >
  context_ (const ::std::string& u,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    ::std::auto_ptr< ::tmx20::context > r (
      ::tmx20::context_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::tmx20::context >
  context_ (const ::std::string& u,
            ::xml_schema::error_handler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::tmx20::context > r (
      ::tmx20::context_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::tmx20::context >
  context_ (const ::std::string& u,
            ::xercesc::DOMErrorHandler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::tmx20::context > r (
      ::tmx20::context_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::tmx20::context >
  context_ (::std::istream& is,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::tmx20::context_ (isrc, f, p);
  }

  ::std::auto_ptr< ::tmx20::context >
  context_ (::std::istream& is,
            ::xml_schema::error_handler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::tmx20::context_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::tmx20::context >
  context_ (::std::istream& is,
            ::xercesc::DOMErrorHandler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::tmx20::context_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::tmx20::context >
  context_ (::std::istream& is,
            const ::std::string& sid,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::tmx20::context_ (isrc, f, p);
  }

  ::std::auto_ptr< ::tmx20::context >
  context_ (::std::istream& is,
            const ::std::string& sid,
            ::xml_schema::error_handler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::tmx20::context_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::tmx20::context >
  context_ (::std::istream& is,
            const ::std::string& sid,
            ::xercesc::DOMErrorHandler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::tmx20::context_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::tmx20::context >
  context_ (::xercesc::InputSource& i,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    ::std::auto_ptr< ::tmx20::context > r (
      ::tmx20::context_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::tmx20::context >
  context_ (::xercesc::InputSource& i,
            ::xml_schema::error_handler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::tmx20::context > r (
      ::tmx20::context_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::tmx20::context >
  context_ (::xercesc::InputSource& i,
            ::xercesc::DOMErrorHandler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::tmx20::context > r (
      ::tmx20::context_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::tmx20::context >
  context_ (const ::xercesc::DOMDocument& d,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    if (f & ::xml_schema::flags::keep_dom)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

      ::std::auto_ptr< ::tmx20::context > r (
        ::tmx20::context_ (
          c, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    const ::xercesc::DOMElement& e (*d.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "context" &&
        n.namespace_ () == "http://www.lisa.org/tmx20")
    {
      ::std::auto_ptr< ::tmx20::context > r (
        ::xsd::cxx::tree::traits< ::tmx20::context, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "context",
      "http://www.lisa.org/tmx20");
  }

  ::std::auto_ptr< ::tmx20::context >
  context_ (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
            ::xml_schema::flags f,
            const ::xml_schema::properties&)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::flags::keep_dom) &&
       !(f & ::xml_schema::flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "context" &&
        n.namespace_ () == "http://www.lisa.org/tmx20")
    {
      ::std::auto_ptr< ::tmx20::context > r (
        ::xsd::cxx::tree::traits< ::tmx20::context, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "context",
      "http://www.lisa.org/tmx20");
  }

  ::std::auto_ptr< ::tmx20::external_file >
  external_file_ (const ::std::string& u,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    ::std::auto_ptr< ::tmx20::external_file > r (
      ::tmx20::external_file_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::tmx20::external_file >
  external_file_ (const ::std::string& u,
                  ::xml_schema::error_handler& h,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::tmx20::external_file > r (
      ::tmx20::external_file_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::tmx20::external_file >
  external_file_ (const ::std::string& u,
                  ::xercesc::DOMErrorHandler& h,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::tmx20::external_file > r (
      ::tmx20::external_file_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::tmx20::external_file >
  external_file_ (::std::istream& is,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::tmx20::external_file_ (isrc, f, p);
  }

  ::std::auto_ptr< ::tmx20::external_file >
  external_file_ (::std::istream& is,
                  ::xml_schema::error_handler& h,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::tmx20::external_file_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::tmx20::external_file >
  external_file_ (::std::istream& is,
                  ::xercesc::DOMErrorHandler& h,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::tmx20::external_file_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::tmx20::external_file >
  external_file_ (::std::istream& is,
                  const ::std::string& sid,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::tmx20::external_file_ (isrc, f, p);
  }

  ::std::auto_ptr< ::tmx20::external_file >
  external_file_ (::std::istream& is,
                  const ::std::string& sid,
                  ::xml_schema::error_handler& h,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::tmx20::external_file_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::tmx20::external_file >
  external_file_ (::std::istream& is,
                  const ::std::string& sid,
                  ::xercesc::DOMErrorHandler& h,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::tmx20::external_file_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::tmx20::external_file >
  external_file_ (::xercesc::InputSource& i,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    ::std::auto_ptr< ::tmx20::external_file > r (
      ::tmx20::external_file_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::tmx20::external_file >
  external_file_ (::xercesc::InputSource& i,
                  ::xml_schema::error_handler& h,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::tmx20::external_file > r (
      ::tmx20::external_file_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::tmx20::external_file >
  external_file_ (::xercesc::InputSource& i,
                  ::xercesc::DOMErrorHandler& h,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::tmx20::external_file > r (
      ::tmx20::external_file_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::tmx20::external_file >
  external_file_ (const ::xercesc::DOMDocument& d,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
  {
    if (f & ::xml_schema::flags::keep_dom)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

      ::std::auto_ptr< ::tmx20::external_file > r (
        ::tmx20::external_file_ (
          c, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    const ::xercesc::DOMElement& e (*d.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "external-file" &&
        n.namespace_ () == "http://www.lisa.org/tmx20")
    {
      ::std::auto_ptr< ::tmx20::external_file > r (
        ::xsd::cxx::tree::traits< ::tmx20::external_file, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "external-file",
      "http://www.lisa.org/tmx20");
  }

  ::std::auto_ptr< ::tmx20::external_file >
  external_file_ (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties&)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::flags::keep_dom) &&
       !(f & ::xml_schema::flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "external-file" &&
        n.namespace_ () == "http://www.lisa.org/tmx20")
    {
      ::std::auto_ptr< ::tmx20::external_file > r (
        ::xsd::cxx::tree::traits< ::tmx20::external_file, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "external-file",
      "http://www.lisa.org/tmx20");
  }

  ::std::auto_ptr< ::tmx20::header >
  header_ (const ::std::string& u,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    ::std::auto_ptr< ::tmx20::header > r (
      ::tmx20::header_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::tmx20::header >
  header_ (const ::std::string& u,
           ::xml_schema::error_handler& h,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::tmx20::header > r (
      ::tmx20::header_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::tmx20::header >
  header_ (const ::std::string& u,
           ::xercesc::DOMErrorHandler& h,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::tmx20::header > r (
      ::tmx20::header_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::tmx20::header >
  header_ (::std::istream& is,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::tmx20::header_ (isrc, f, p);
  }

  ::std::auto_ptr< ::tmx20::header >
  header_ (::std::istream& is,
           ::xml_schema::error_handler& h,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::tmx20::header_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::tmx20::header >
  header_ (::std::istream& is,
           ::xercesc::DOMErrorHandler& h,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::tmx20::header_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::tmx20::header >
  header_ (::std::istream& is,
           const ::std::string& sid,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::tmx20::header_ (isrc, f, p);
  }

  ::std::auto_ptr< ::tmx20::header >
  header_ (::std::istream& is,
           const ::std::string& sid,
           ::xml_schema::error_handler& h,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::tmx20::header_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::tmx20::header >
  header_ (::std::istream& is,
           const ::std::string& sid,
           ::xercesc::DOMErrorHandler& h,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::tmx20::header_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::tmx20::header >
  header_ (::xercesc::InputSource& i,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    ::std::auto_ptr< ::tmx20::header > r (
      ::tmx20::header_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::tmx20::header >
  header_ (::xercesc::InputSource& i,
           ::xml_schema::error_handler& h,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::tmx20::header > r (
      ::tmx20::header_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::tmx20::header >
  header_ (::xercesc::InputSource& i,
           ::xercesc::DOMErrorHandler& h,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::tmx20::header > r (
      ::tmx20::header_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::tmx20::header >
  header_ (const ::xercesc::DOMDocument& d,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
  {
    if (f & ::xml_schema::flags::keep_dom)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

      ::std::auto_ptr< ::tmx20::header > r (
        ::tmx20::header_ (
          c, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    const ::xercesc::DOMElement& e (*d.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "header" &&
        n.namespace_ () == "http://www.lisa.org/tmx20")
    {
      ::std::auto_ptr< ::tmx20::header > r (
        ::xsd::cxx::tree::traits< ::tmx20::header, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "header",
      "http://www.lisa.org/tmx20");
  }

  ::std::auto_ptr< ::tmx20::header >
  header_ (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
           ::xml_schema::flags f,
           const ::xml_schema::properties&)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::flags::keep_dom) &&
       !(f & ::xml_schema::flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "header" &&
        n.namespace_ () == "http://www.lisa.org/tmx20")
    {
      ::std::auto_ptr< ::tmx20::header > r (
        ::xsd::cxx::tree::traits< ::tmx20::header, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "header",
      "http://www.lisa.org/tmx20");
  }

  ::std::auto_ptr< ::tmx20::inline_data >
  inline_data_ (const ::std::string& u,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    ::std::auto_ptr< ::tmx20::inline_data > r (
      ::tmx20::inline_data_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::tmx20::inline_data >
  inline_data_ (const ::std::string& u,
                ::xml_schema::error_handler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::tmx20::inline_data > r (
      ::tmx20::inline_data_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::tmx20::inline_data >
  inline_data_ (const ::std::string& u,
                ::xercesc::DOMErrorHandler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::tmx20::inline_data > r (
      ::tmx20::inline_data_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::tmx20::inline_data >
  inline_data_ (::std::istream& is,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::tmx20::inline_data_ (isrc, f, p);
  }

  ::std::auto_ptr< ::tmx20::inline_data >
  inline_data_ (::std::istream& is,
                ::xml_schema::error_handler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::tmx20::inline_data_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::tmx20::inline_data >
  inline_data_ (::std::istream& is,
                ::xercesc::DOMErrorHandler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::tmx20::inline_data_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::tmx20::inline_data >
  inline_data_ (::std::istream& is,
                const ::std::string& sid,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::tmx20::inline_data_ (isrc, f, p);
  }

  ::std::auto_ptr< ::tmx20::inline_data >
  inline_data_ (::std::istream& is,
                const ::std::string& sid,
                ::xml_schema::error_handler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::tmx20::inline_data_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::tmx20::inline_data >
  inline_data_ (::std::istream& is,
                const ::std::string& sid,
                ::xercesc::DOMErrorHandler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::tmx20::inline_data_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::tmx20::inline_data >
  inline_data_ (::xercesc::InputSource& i,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    ::std::auto_ptr< ::tmx20::inline_data > r (
      ::tmx20::inline_data_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::tmx20::inline_data >
  inline_data_ (::xercesc::InputSource& i,
                ::xml_schema::error_handler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::tmx20::inline_data > r (
      ::tmx20::inline_data_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::tmx20::inline_data >
  inline_data_ (::xercesc::InputSource& i,
                ::xercesc::DOMErrorHandler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::tmx20::inline_data > r (
      ::tmx20::inline_data_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::tmx20::inline_data >
  inline_data_ (const ::xercesc::DOMDocument& d,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    if (f & ::xml_schema::flags::keep_dom)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

      ::std::auto_ptr< ::tmx20::inline_data > r (
        ::tmx20::inline_data_ (
          c, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    const ::xercesc::DOMElement& e (*d.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "inline-data" &&
        n.namespace_ () == "http://www.lisa.org/tmx20")
    {
      ::std::auto_ptr< ::tmx20::inline_data > r (
        ::xsd::cxx::tree::traits< ::tmx20::inline_data, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "inline-data",
      "http://www.lisa.org/tmx20");
  }

  ::std::auto_ptr< ::tmx20::inline_data >
  inline_data_ (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
                ::xml_schema::flags f,
                const ::xml_schema::properties&)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::flags::keep_dom) &&
       !(f & ::xml_schema::flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "inline-data" &&
        n.namespace_ () == "http://www.lisa.org/tmx20")
    {
      ::std::auto_ptr< ::tmx20::inline_data > r (
        ::xsd::cxx::tree::traits< ::tmx20::inline_data, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "inline-data",
      "http://www.lisa.org/tmx20");
  }

  ::std::auto_ptr< ::tmx20::internal_file >
  internal_file_ (const ::std::string& u,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    ::std::auto_ptr< ::tmx20::internal_file > r (
      ::tmx20::internal_file_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::tmx20::internal_file >
  internal_file_ (const ::std::string& u,
                  ::xml_schema::error_handler& h,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::tmx20::internal_file > r (
      ::tmx20::internal_file_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::tmx20::internal_file >
  internal_file_ (const ::std::string& u,
                  ::xercesc::DOMErrorHandler& h,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::tmx20::internal_file > r (
      ::tmx20::internal_file_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::tmx20::internal_file >
  internal_file_ (::std::istream& is,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::tmx20::internal_file_ (isrc, f, p);
  }

  ::std::auto_ptr< ::tmx20::internal_file >
  internal_file_ (::std::istream& is,
                  ::xml_schema::error_handler& h,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::tmx20::internal_file_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::tmx20::internal_file >
  internal_file_ (::std::istream& is,
                  ::xercesc::DOMErrorHandler& h,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::tmx20::internal_file_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::tmx20::internal_file >
  internal_file_ (::std::istream& is,
                  const ::std::string& sid,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::tmx20::internal_file_ (isrc, f, p);
  }

  ::std::auto_ptr< ::tmx20::internal_file >
  internal_file_ (::std::istream& is,
                  const ::std::string& sid,
                  ::xml_schema::error_handler& h,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::tmx20::internal_file_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::tmx20::internal_file >
  internal_file_ (::std::istream& is,
                  const ::std::string& sid,
                  ::xercesc::DOMErrorHandler& h,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::tmx20::internal_file_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::tmx20::internal_file >
  internal_file_ (::xercesc::InputSource& i,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    ::std::auto_ptr< ::tmx20::internal_file > r (
      ::tmx20::internal_file_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::tmx20::internal_file >
  internal_file_ (::xercesc::InputSource& i,
                  ::xml_schema::error_handler& h,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::tmx20::internal_file > r (
      ::tmx20::internal_file_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::tmx20::internal_file >
  internal_file_ (::xercesc::InputSource& i,
                  ::xercesc::DOMErrorHandler& h,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::tmx20::internal_file > r (
      ::tmx20::internal_file_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::tmx20::internal_file >
  internal_file_ (const ::xercesc::DOMDocument& d,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
  {
    if (f & ::xml_schema::flags::keep_dom)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

      ::std::auto_ptr< ::tmx20::internal_file > r (
        ::tmx20::internal_file_ (
          c, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    const ::xercesc::DOMElement& e (*d.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "internal-file" &&
        n.namespace_ () == "http://www.lisa.org/tmx20")
    {
      ::std::auto_ptr< ::tmx20::internal_file > r (
        ::xsd::cxx::tree::traits< ::tmx20::internal_file, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "internal-file",
      "http://www.lisa.org/tmx20");
  }

  ::std::auto_ptr< ::tmx20::internal_file >
  internal_file_ (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties&)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::flags::keep_dom) &&
       !(f & ::xml_schema::flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "internal-file" &&
        n.namespace_ () == "http://www.lisa.org/tmx20")
    {
      ::std::auto_ptr< ::tmx20::internal_file > r (
        ::xsd::cxx::tree::traits< ::tmx20::internal_file, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "internal-file",
      "http://www.lisa.org/tmx20");
  }

  ::std::auto_ptr< ::tmx20::note >
  note_ (const ::std::string& u,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    ::std::auto_ptr< ::tmx20::note > r (
      ::tmx20::note_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::tmx20::note >
  note_ (const ::std::string& u,
         ::xml_schema::error_handler& h,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::tmx20::note > r (
      ::tmx20::note_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::tmx20::note >
  note_ (const ::std::string& u,
         ::xercesc::DOMErrorHandler& h,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::tmx20::note > r (
      ::tmx20::note_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::tmx20::note >
  note_ (::std::istream& is,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::tmx20::note_ (isrc, f, p);
  }

  ::std::auto_ptr< ::tmx20::note >
  note_ (::std::istream& is,
         ::xml_schema::error_handler& h,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::tmx20::note_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::tmx20::note >
  note_ (::std::istream& is,
         ::xercesc::DOMErrorHandler& h,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::tmx20::note_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::tmx20::note >
  note_ (::std::istream& is,
         const ::std::string& sid,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::tmx20::note_ (isrc, f, p);
  }

  ::std::auto_ptr< ::tmx20::note >
  note_ (::std::istream& is,
         const ::std::string& sid,
         ::xml_schema::error_handler& h,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::tmx20::note_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::tmx20::note >
  note_ (::std::istream& is,
         const ::std::string& sid,
         ::xercesc::DOMErrorHandler& h,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::tmx20::note_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::tmx20::note >
  note_ (::xercesc::InputSource& i,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    ::std::auto_ptr< ::tmx20::note > r (
      ::tmx20::note_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::tmx20::note >
  note_ (::xercesc::InputSource& i,
         ::xml_schema::error_handler& h,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::tmx20::note > r (
      ::tmx20::note_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::tmx20::note >
  note_ (::xercesc::InputSource& i,
         ::xercesc::DOMErrorHandler& h,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::tmx20::note > r (
      ::tmx20::note_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::tmx20::note >
  note_ (const ::xercesc::DOMDocument& d,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
  {
    if (f & ::xml_schema::flags::keep_dom)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

      ::std::auto_ptr< ::tmx20::note > r (
        ::tmx20::note_ (
          c, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    const ::xercesc::DOMElement& e (*d.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "note" &&
        n.namespace_ () == "http://www.lisa.org/tmx20")
    {
      ::std::auto_ptr< ::tmx20::note > r (
        ::xsd::cxx::tree::traits< ::tmx20::note, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "note",
      "http://www.lisa.org/tmx20");
  }

  ::std::auto_ptr< ::tmx20::note >
  note_ (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
         ::xml_schema::flags f,
         const ::xml_schema::properties&)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::flags::keep_dom) &&
       !(f & ::xml_schema::flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "note" &&
        n.namespace_ () == "http://www.lisa.org/tmx20")
    {
      ::std::auto_ptr< ::tmx20::note > r (
        ::xsd::cxx::tree::traits< ::tmx20::note, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "note",
      "http://www.lisa.org/tmx20");
  }

  ::std::auto_ptr< ::tmx20::prop >
  prop_ (const ::std::string& u,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    ::std::auto_ptr< ::tmx20::prop > r (
      ::tmx20::prop_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::tmx20::prop >
  prop_ (const ::std::string& u,
         ::xml_schema::error_handler& h,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::tmx20::prop > r (
      ::tmx20::prop_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::tmx20::prop >
  prop_ (const ::std::string& u,
         ::xercesc::DOMErrorHandler& h,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::tmx20::prop > r (
      ::tmx20::prop_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::tmx20::prop >
  prop_ (::std::istream& is,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::tmx20::prop_ (isrc, f, p);
  }

  ::std::auto_ptr< ::tmx20::prop >
  prop_ (::std::istream& is,
         ::xml_schema::error_handler& h,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::tmx20::prop_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::tmx20::prop >
  prop_ (::std::istream& is,
         ::xercesc::DOMErrorHandler& h,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::tmx20::prop_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::tmx20::prop >
  prop_ (::std::istream& is,
         const ::std::string& sid,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::tmx20::prop_ (isrc, f, p);
  }

  ::std::auto_ptr< ::tmx20::prop >
  prop_ (::std::istream& is,
         const ::std::string& sid,
         ::xml_schema::error_handler& h,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::tmx20::prop_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::tmx20::prop >
  prop_ (::std::istream& is,
         const ::std::string& sid,
         ::xercesc::DOMErrorHandler& h,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::tmx20::prop_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::tmx20::prop >
  prop_ (::xercesc::InputSource& i,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    ::std::auto_ptr< ::tmx20::prop > r (
      ::tmx20::prop_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::tmx20::prop >
  prop_ (::xercesc::InputSource& i,
         ::xml_schema::error_handler& h,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::tmx20::prop > r (
      ::tmx20::prop_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::tmx20::prop >
  prop_ (::xercesc::InputSource& i,
         ::xercesc::DOMErrorHandler& h,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::tmx20::prop > r (
      ::tmx20::prop_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::tmx20::prop >
  prop_ (const ::xercesc::DOMDocument& d,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
  {
    if (f & ::xml_schema::flags::keep_dom)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

      ::std::auto_ptr< ::tmx20::prop > r (
        ::tmx20::prop_ (
          c, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    const ::xercesc::DOMElement& e (*d.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "prop" &&
        n.namespace_ () == "http://www.lisa.org/tmx20")
    {
      ::std::auto_ptr< ::tmx20::prop > r (
        ::xsd::cxx::tree::traits< ::tmx20::prop, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "prop",
      "http://www.lisa.org/tmx20");
  }

  ::std::auto_ptr< ::tmx20::prop >
  prop_ (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
         ::xml_schema::flags f,
         const ::xml_schema::properties&)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::flags::keep_dom) &&
       !(f & ::xml_schema::flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "prop" &&
        n.namespace_ () == "http://www.lisa.org/tmx20")
    {
      ::std::auto_ptr< ::tmx20::prop > r (
        ::xsd::cxx::tree::traits< ::tmx20::prop, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "prop",
      "http://www.lisa.org/tmx20");
  }

  ::std::auto_ptr< ::tmx20::seg >
  seg_ (const ::std::string& u,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    ::std::auto_ptr< ::tmx20::seg > r (
      ::tmx20::seg_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::tmx20::seg >
  seg_ (const ::std::string& u,
        ::xml_schema::error_handler& h,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::tmx20::seg > r (
      ::tmx20::seg_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::tmx20::seg >
  seg_ (const ::std::string& u,
        ::xercesc::DOMErrorHandler& h,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::tmx20::seg > r (
      ::tmx20::seg_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::tmx20::seg >
  seg_ (::std::istream& is,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::tmx20::seg_ (isrc, f, p);
  }

  ::std::auto_ptr< ::tmx20::seg >
  seg_ (::std::istream& is,
        ::xml_schema::error_handler& h,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::tmx20::seg_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::tmx20::seg >
  seg_ (::std::istream& is,
        ::xercesc::DOMErrorHandler& h,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::tmx20::seg_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::tmx20::seg >
  seg_ (::std::istream& is,
        const ::std::string& sid,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::tmx20::seg_ (isrc, f, p);
  }

  ::std::auto_ptr< ::tmx20::seg >
  seg_ (::std::istream& is,
        const ::std::string& sid,
        ::xml_schema::error_handler& h,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::tmx20::seg_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::tmx20::seg >
  seg_ (::std::istream& is,
        const ::std::string& sid,
        ::xercesc::DOMErrorHandler& h,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::tmx20::seg_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::tmx20::seg >
  seg_ (::xercesc::InputSource& i,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    ::std::auto_ptr< ::tmx20::seg > r (
      ::tmx20::seg_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::tmx20::seg >
  seg_ (::xercesc::InputSource& i,
        ::xml_schema::error_handler& h,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::tmx20::seg > r (
      ::tmx20::seg_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::tmx20::seg >
  seg_ (::xercesc::InputSource& i,
        ::xercesc::DOMErrorHandler& h,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::tmx20::seg > r (
      ::tmx20::seg_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::tmx20::seg >
  seg_ (const ::xercesc::DOMDocument& d,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
  {
    if (f & ::xml_schema::flags::keep_dom)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

      ::std::auto_ptr< ::tmx20::seg > r (
        ::tmx20::seg_ (
          c, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    const ::xercesc::DOMElement& e (*d.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "seg" &&
        n.namespace_ () == "http://www.lisa.org/tmx20")
    {
      ::std::auto_ptr< ::tmx20::seg > r (
        ::xsd::cxx::tree::traits< ::tmx20::seg, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "seg",
      "http://www.lisa.org/tmx20");
  }

  ::std::auto_ptr< ::tmx20::seg >
  seg_ (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
        ::xml_schema::flags f,
        const ::xml_schema::properties&)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::flags::keep_dom) &&
       !(f & ::xml_schema::flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "seg" &&
        n.namespace_ () == "http://www.lisa.org/tmx20")
    {
      ::std::auto_ptr< ::tmx20::seg > r (
        ::xsd::cxx::tree::traits< ::tmx20::seg, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "seg",
      "http://www.lisa.org/tmx20");
  }

  ::std::auto_ptr< ::tmx20::segmentation >
  segmentation_ (const ::std::string& u,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    ::std::auto_ptr< ::tmx20::segmentation > r (
      ::tmx20::segmentation_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::tmx20::segmentation >
  segmentation_ (const ::std::string& u,
                 ::xml_schema::error_handler& h,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::tmx20::segmentation > r (
      ::tmx20::segmentation_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::tmx20::segmentation >
  segmentation_ (const ::std::string& u,
                 ::xercesc::DOMErrorHandler& h,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::tmx20::segmentation > r (
      ::tmx20::segmentation_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::tmx20::segmentation >
  segmentation_ (::std::istream& is,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::tmx20::segmentation_ (isrc, f, p);
  }

  ::std::auto_ptr< ::tmx20::segmentation >
  segmentation_ (::std::istream& is,
                 ::xml_schema::error_handler& h,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::tmx20::segmentation_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::tmx20::segmentation >
  segmentation_ (::std::istream& is,
                 ::xercesc::DOMErrorHandler& h,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::tmx20::segmentation_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::tmx20::segmentation >
  segmentation_ (::std::istream& is,
                 const ::std::string& sid,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::tmx20::segmentation_ (isrc, f, p);
  }

  ::std::auto_ptr< ::tmx20::segmentation >
  segmentation_ (::std::istream& is,
                 const ::std::string& sid,
                 ::xml_schema::error_handler& h,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::tmx20::segmentation_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::tmx20::segmentation >
  segmentation_ (::std::istream& is,
                 const ::std::string& sid,
                 ::xercesc::DOMErrorHandler& h,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::tmx20::segmentation_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::tmx20::segmentation >
  segmentation_ (::xercesc::InputSource& i,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    ::std::auto_ptr< ::tmx20::segmentation > r (
      ::tmx20::segmentation_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::tmx20::segmentation >
  segmentation_ (::xercesc::InputSource& i,
                 ::xml_schema::error_handler& h,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::tmx20::segmentation > r (
      ::tmx20::segmentation_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::tmx20::segmentation >
  segmentation_ (::xercesc::InputSource& i,
                 ::xercesc::DOMErrorHandler& h,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::tmx20::segmentation > r (
      ::tmx20::segmentation_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::tmx20::segmentation >
  segmentation_ (const ::xercesc::DOMDocument& d,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
  {
    if (f & ::xml_schema::flags::keep_dom)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

      ::std::auto_ptr< ::tmx20::segmentation > r (
        ::tmx20::segmentation_ (
          c, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    const ::xercesc::DOMElement& e (*d.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "segmentation" &&
        n.namespace_ () == "http://www.lisa.org/tmx20")
    {
      ::std::auto_ptr< ::tmx20::segmentation > r (
        ::xsd::cxx::tree::traits< ::tmx20::segmentation, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "segmentation",
      "http://www.lisa.org/tmx20");
  }

  ::std::auto_ptr< ::tmx20::segmentation >
  segmentation_ (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties&)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::flags::keep_dom) &&
       !(f & ::xml_schema::flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "segmentation" &&
        n.namespace_ () == "http://www.lisa.org/tmx20")
    {
      ::std::auto_ptr< ::tmx20::segmentation > r (
        ::xsd::cxx::tree::traits< ::tmx20::segmentation, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "segmentation",
      "http://www.lisa.org/tmx20");
  }

  ::std::auto_ptr< ::tmx20::tag >
  tag_ (const ::std::string& u,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    ::std::auto_ptr< ::tmx20::tag > r (
      ::tmx20::tag_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::tmx20::tag >
  tag_ (const ::std::string& u,
        ::xml_schema::error_handler& h,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::tmx20::tag > r (
      ::tmx20::tag_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::tmx20::tag >
  tag_ (const ::std::string& u,
        ::xercesc::DOMErrorHandler& h,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::tmx20::tag > r (
      ::tmx20::tag_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::tmx20::tag >
  tag_ (::std::istream& is,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::tmx20::tag_ (isrc, f, p);
  }

  ::std::auto_ptr< ::tmx20::tag >
  tag_ (::std::istream& is,
        ::xml_schema::error_handler& h,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::tmx20::tag_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::tmx20::tag >
  tag_ (::std::istream& is,
        ::xercesc::DOMErrorHandler& h,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::tmx20::tag_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::tmx20::tag >
  tag_ (::std::istream& is,
        const ::std::string& sid,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::tmx20::tag_ (isrc, f, p);
  }

  ::std::auto_ptr< ::tmx20::tag >
  tag_ (::std::istream& is,
        const ::std::string& sid,
        ::xml_schema::error_handler& h,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::tmx20::tag_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::tmx20::tag >
  tag_ (::std::istream& is,
        const ::std::string& sid,
        ::xercesc::DOMErrorHandler& h,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::tmx20::tag_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::tmx20::tag >
  tag_ (::xercesc::InputSource& i,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    ::std::auto_ptr< ::tmx20::tag > r (
      ::tmx20::tag_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::tmx20::tag >
  tag_ (::xercesc::InputSource& i,
        ::xml_schema::error_handler& h,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::tmx20::tag > r (
      ::tmx20::tag_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::tmx20::tag >
  tag_ (::xercesc::InputSource& i,
        ::xercesc::DOMErrorHandler& h,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::tmx20::tag > r (
      ::tmx20::tag_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::tmx20::tag >
  tag_ (const ::xercesc::DOMDocument& d,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
  {
    if (f & ::xml_schema::flags::keep_dom)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

      ::std::auto_ptr< ::tmx20::tag > r (
        ::tmx20::tag_ (
          c, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    const ::xercesc::DOMElement& e (*d.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "tag" &&
        n.namespace_ () == "http://www.lisa.org/tmx20")
    {
      ::std::auto_ptr< ::tmx20::tag > r (
        ::xsd::cxx::tree::traits< ::tmx20::tag, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "tag",
      "http://www.lisa.org/tmx20");
  }

  ::std::auto_ptr< ::tmx20::tag >
  tag_ (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
        ::xml_schema::flags f,
        const ::xml_schema::properties&)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::flags::keep_dom) &&
       !(f & ::xml_schema::flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "tag" &&
        n.namespace_ () == "http://www.lisa.org/tmx20")
    {
      ::std::auto_ptr< ::tmx20::tag > r (
        ::xsd::cxx::tree::traits< ::tmx20::tag, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "tag",
      "http://www.lisa.org/tmx20");
  }

  ::std::auto_ptr< ::tmx20::tu >
  tu_ (const ::std::string& u,
       ::xml_schema::flags f,
       const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    ::std::auto_ptr< ::tmx20::tu > r (
      ::tmx20::tu_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::tmx20::tu >
  tu_ (const ::std::string& u,
       ::xml_schema::error_handler& h,
       ::xml_schema::flags f,
       const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::tmx20::tu > r (
      ::tmx20::tu_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::tmx20::tu >
  tu_ (const ::std::string& u,
       ::xercesc::DOMErrorHandler& h,
       ::xml_schema::flags f,
       const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::tmx20::tu > r (
      ::tmx20::tu_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::tmx20::tu >
  tu_ (::std::istream& is,
       ::xml_schema::flags f,
       const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::tmx20::tu_ (isrc, f, p);
  }

  ::std::auto_ptr< ::tmx20::tu >
  tu_ (::std::istream& is,
       ::xml_schema::error_handler& h,
       ::xml_schema::flags f,
       const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::tmx20::tu_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::tmx20::tu >
  tu_ (::std::istream& is,
       ::xercesc::DOMErrorHandler& h,
       ::xml_schema::flags f,
       const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::tmx20::tu_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::tmx20::tu >
  tu_ (::std::istream& is,
       const ::std::string& sid,
       ::xml_schema::flags f,
       const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::tmx20::tu_ (isrc, f, p);
  }

  ::std::auto_ptr< ::tmx20::tu >
  tu_ (::std::istream& is,
       const ::std::string& sid,
       ::xml_schema::error_handler& h,
       ::xml_schema::flags f,
       const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::tmx20::tu_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::tmx20::tu >
  tu_ (::std::istream& is,
       const ::std::string& sid,
       ::xercesc::DOMErrorHandler& h,
       ::xml_schema::flags f,
       const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::tmx20::tu_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::tmx20::tu >
  tu_ (::xercesc::InputSource& i,
       ::xml_schema::flags f,
       const ::xml_schema::properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    ::std::auto_ptr< ::tmx20::tu > r (
      ::tmx20::tu_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::tmx20::tu >
  tu_ (::xercesc::InputSource& i,
       ::xml_schema::error_handler& h,
       ::xml_schema::flags f,
       const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::tmx20::tu > r (
      ::tmx20::tu_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::tmx20::tu >
  tu_ (::xercesc::InputSource& i,
       ::xercesc::DOMErrorHandler& h,
       ::xml_schema::flags f,
       const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::tmx20::tu > r (
      ::tmx20::tu_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::tmx20::tu >
  tu_ (const ::xercesc::DOMDocument& d,
       ::xml_schema::flags f,
       const ::xml_schema::properties& p)
  {
    if (f & ::xml_schema::flags::keep_dom)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

      ::std::auto_ptr< ::tmx20::tu > r (
        ::tmx20::tu_ (
          c, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    const ::xercesc::DOMElement& e (*d.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "tu" &&
        n.namespace_ () == "http://www.lisa.org/tmx20")
    {
      ::std::auto_ptr< ::tmx20::tu > r (
        ::xsd::cxx::tree::traits< ::tmx20::tu, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "tu",
      "http://www.lisa.org/tmx20");
  }

  ::std::auto_ptr< ::tmx20::tu >
  tu_ (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
       ::xml_schema::flags f,
       const ::xml_schema::properties&)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::flags::keep_dom) &&
       !(f & ::xml_schema::flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "tu" &&
        n.namespace_ () == "http://www.lisa.org/tmx20")
    {
      ::std::auto_ptr< ::tmx20::tu > r (
        ::xsd::cxx::tree::traits< ::tmx20::tu, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "tu",
      "http://www.lisa.org/tmx20");
  }

  ::std::auto_ptr< ::tmx20::tuv >
  tuv_ (const ::std::string& u,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    ::std::auto_ptr< ::tmx20::tuv > r (
      ::tmx20::tuv_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::tmx20::tuv >
  tuv_ (const ::std::string& u,
        ::xml_schema::error_handler& h,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::tmx20::tuv > r (
      ::tmx20::tuv_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::tmx20::tuv >
  tuv_ (const ::std::string& u,
        ::xercesc::DOMErrorHandler& h,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::tmx20::tuv > r (
      ::tmx20::tuv_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::tmx20::tuv >
  tuv_ (::std::istream& is,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::tmx20::tuv_ (isrc, f, p);
  }

  ::std::auto_ptr< ::tmx20::tuv >
  tuv_ (::std::istream& is,
        ::xml_schema::error_handler& h,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::tmx20::tuv_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::tmx20::tuv >
  tuv_ (::std::istream& is,
        ::xercesc::DOMErrorHandler& h,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::tmx20::tuv_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::tmx20::tuv >
  tuv_ (::std::istream& is,
        const ::std::string& sid,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::tmx20::tuv_ (isrc, f, p);
  }

  ::std::auto_ptr< ::tmx20::tuv >
  tuv_ (::std::istream& is,
        const ::std::string& sid,
        ::xml_schema::error_handler& h,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::tmx20::tuv_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::tmx20::tuv >
  tuv_ (::std::istream& is,
        const ::std::string& sid,
        ::xercesc::DOMErrorHandler& h,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::tmx20::tuv_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::tmx20::tuv >
  tuv_ (::xercesc::InputSource& i,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    ::std::auto_ptr< ::tmx20::tuv > r (
      ::tmx20::tuv_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::tmx20::tuv >
  tuv_ (::xercesc::InputSource& i,
        ::xml_schema::error_handler& h,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::tmx20::tuv > r (
      ::tmx20::tuv_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::tmx20::tuv >
  tuv_ (::xercesc::InputSource& i,
        ::xercesc::DOMErrorHandler& h,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::tmx20::tuv > r (
      ::tmx20::tuv_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::tmx20::tuv >
  tuv_ (const ::xercesc::DOMDocument& d,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
  {
    if (f & ::xml_schema::flags::keep_dom)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

      ::std::auto_ptr< ::tmx20::tuv > r (
        ::tmx20::tuv_ (
          c, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    const ::xercesc::DOMElement& e (*d.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "tuv" &&
        n.namespace_ () == "http://www.lisa.org/tmx20")
    {
      ::std::auto_ptr< ::tmx20::tuv > r (
        ::xsd::cxx::tree::traits< ::tmx20::tuv, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "tuv",
      "http://www.lisa.org/tmx20");
  }

  ::std::auto_ptr< ::tmx20::tuv >
  tuv_ (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
        ::xml_schema::flags f,
        const ::xml_schema::properties&)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::flags::keep_dom) &&
       !(f & ::xml_schema::flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "tuv" &&
        n.namespace_ () == "http://www.lisa.org/tmx20")
    {
      ::std::auto_ptr< ::tmx20::tuv > r (
        ::xsd::cxx::tree::traits< ::tmx20::tuv, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "tuv",
      "http://www.lisa.org/tmx20");
  }

  ::std::auto_ptr< ::tmx20::bpt >
  bpt_ (const ::std::string& u,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    ::std::auto_ptr< ::tmx20::bpt > r (
      ::tmx20::bpt_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::tmx20::bpt >
  bpt_ (const ::std::string& u,
        ::xml_schema::error_handler& h,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::tmx20::bpt > r (
      ::tmx20::bpt_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::tmx20::bpt >
  bpt_ (const ::std::string& u,
        ::xercesc::DOMErrorHandler& h,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::tmx20::bpt > r (
      ::tmx20::bpt_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::tmx20::bpt >
  bpt_ (::std::istream& is,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::tmx20::bpt_ (isrc, f, p);
  }

  ::std::auto_ptr< ::tmx20::bpt >
  bpt_ (::std::istream& is,
        ::xml_schema::error_handler& h,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::tmx20::bpt_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::tmx20::bpt >
  bpt_ (::std::istream& is,
        ::xercesc::DOMErrorHandler& h,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::tmx20::bpt_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::tmx20::bpt >
  bpt_ (::std::istream& is,
        const ::std::string& sid,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::tmx20::bpt_ (isrc, f, p);
  }

  ::std::auto_ptr< ::tmx20::bpt >
  bpt_ (::std::istream& is,
        const ::std::string& sid,
        ::xml_schema::error_handler& h,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::tmx20::bpt_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::tmx20::bpt >
  bpt_ (::std::istream& is,
        const ::std::string& sid,
        ::xercesc::DOMErrorHandler& h,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::tmx20::bpt_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::tmx20::bpt >
  bpt_ (::xercesc::InputSource& i,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    ::std::auto_ptr< ::tmx20::bpt > r (
      ::tmx20::bpt_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::tmx20::bpt >
  bpt_ (::xercesc::InputSource& i,
        ::xml_schema::error_handler& h,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::tmx20::bpt > r (
      ::tmx20::bpt_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::tmx20::bpt >
  bpt_ (::xercesc::InputSource& i,
        ::xercesc::DOMErrorHandler& h,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::tmx20::bpt > r (
      ::tmx20::bpt_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::tmx20::bpt >
  bpt_ (const ::xercesc::DOMDocument& d,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
  {
    if (f & ::xml_schema::flags::keep_dom)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

      ::std::auto_ptr< ::tmx20::bpt > r (
        ::tmx20::bpt_ (
          c, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    const ::xercesc::DOMElement& e (*d.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "bpt" &&
        n.namespace_ () == "http://www.lisa.org/tmx20")
    {
      ::std::auto_ptr< ::tmx20::bpt > r (
        ::xsd::cxx::tree::traits< ::tmx20::bpt, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "bpt",
      "http://www.lisa.org/tmx20");
  }

  ::std::auto_ptr< ::tmx20::bpt >
  bpt_ (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
        ::xml_schema::flags f,
        const ::xml_schema::properties&)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::flags::keep_dom) &&
       !(f & ::xml_schema::flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "bpt" &&
        n.namespace_ () == "http://www.lisa.org/tmx20")
    {
      ::std::auto_ptr< ::tmx20::bpt > r (
        ::xsd::cxx::tree::traits< ::tmx20::bpt, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "bpt",
      "http://www.lisa.org/tmx20");
  }

  ::std::auto_ptr< ::tmx20::ept >
  ept_ (const ::std::string& u,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    ::std::auto_ptr< ::tmx20::ept > r (
      ::tmx20::ept_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::tmx20::ept >
  ept_ (const ::std::string& u,
        ::xml_schema::error_handler& h,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::tmx20::ept > r (
      ::tmx20::ept_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::tmx20::ept >
  ept_ (const ::std::string& u,
        ::xercesc::DOMErrorHandler& h,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::tmx20::ept > r (
      ::tmx20::ept_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::tmx20::ept >
  ept_ (::std::istream& is,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::tmx20::ept_ (isrc, f, p);
  }

  ::std::auto_ptr< ::tmx20::ept >
  ept_ (::std::istream& is,
        ::xml_schema::error_handler& h,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::tmx20::ept_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::tmx20::ept >
  ept_ (::std::istream& is,
        ::xercesc::DOMErrorHandler& h,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::tmx20::ept_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::tmx20::ept >
  ept_ (::std::istream& is,
        const ::std::string& sid,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::tmx20::ept_ (isrc, f, p);
  }

  ::std::auto_ptr< ::tmx20::ept >
  ept_ (::std::istream& is,
        const ::std::string& sid,
        ::xml_schema::error_handler& h,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::tmx20::ept_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::tmx20::ept >
  ept_ (::std::istream& is,
        const ::std::string& sid,
        ::xercesc::DOMErrorHandler& h,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::tmx20::ept_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::tmx20::ept >
  ept_ (::xercesc::InputSource& i,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    ::std::auto_ptr< ::tmx20::ept > r (
      ::tmx20::ept_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::tmx20::ept >
  ept_ (::xercesc::InputSource& i,
        ::xml_schema::error_handler& h,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::tmx20::ept > r (
      ::tmx20::ept_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::tmx20::ept >
  ept_ (::xercesc::InputSource& i,
        ::xercesc::DOMErrorHandler& h,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::tmx20::ept > r (
      ::tmx20::ept_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::tmx20::ept >
  ept_ (const ::xercesc::DOMDocument& d,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
  {
    if (f & ::xml_schema::flags::keep_dom)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

      ::std::auto_ptr< ::tmx20::ept > r (
        ::tmx20::ept_ (
          c, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    const ::xercesc::DOMElement& e (*d.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "ept" &&
        n.namespace_ () == "http://www.lisa.org/tmx20")
    {
      ::std::auto_ptr< ::tmx20::ept > r (
        ::xsd::cxx::tree::traits< ::tmx20::ept, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "ept",
      "http://www.lisa.org/tmx20");
  }

  ::std::auto_ptr< ::tmx20::ept >
  ept_ (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
        ::xml_schema::flags f,
        const ::xml_schema::properties&)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::flags::keep_dom) &&
       !(f & ::xml_schema::flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "ept" &&
        n.namespace_ () == "http://www.lisa.org/tmx20")
    {
      ::std::auto_ptr< ::tmx20::ept > r (
        ::xsd::cxx::tree::traits< ::tmx20::ept, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "ept",
      "http://www.lisa.org/tmx20");
  }

  ::std::auto_ptr< ::tmx20::g >
  g_ (const ::std::string& u,
      ::xml_schema::flags f,
      const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    ::std::auto_ptr< ::tmx20::g > r (
      ::tmx20::g_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::tmx20::g >
  g_ (const ::std::string& u,
      ::xml_schema::error_handler& h,
      ::xml_schema::flags f,
      const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::tmx20::g > r (
      ::tmx20::g_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::tmx20::g >
  g_ (const ::std::string& u,
      ::xercesc::DOMErrorHandler& h,
      ::xml_schema::flags f,
      const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::tmx20::g > r (
      ::tmx20::g_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::tmx20::g >
  g_ (::std::istream& is,
      ::xml_schema::flags f,
      const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::tmx20::g_ (isrc, f, p);
  }

  ::std::auto_ptr< ::tmx20::g >
  g_ (::std::istream& is,
      ::xml_schema::error_handler& h,
      ::xml_schema::flags f,
      const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::tmx20::g_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::tmx20::g >
  g_ (::std::istream& is,
      ::xercesc::DOMErrorHandler& h,
      ::xml_schema::flags f,
      const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::tmx20::g_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::tmx20::g >
  g_ (::std::istream& is,
      const ::std::string& sid,
      ::xml_schema::flags f,
      const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::tmx20::g_ (isrc, f, p);
  }

  ::std::auto_ptr< ::tmx20::g >
  g_ (::std::istream& is,
      const ::std::string& sid,
      ::xml_schema::error_handler& h,
      ::xml_schema::flags f,
      const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::tmx20::g_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::tmx20::g >
  g_ (::std::istream& is,
      const ::std::string& sid,
      ::xercesc::DOMErrorHandler& h,
      ::xml_schema::flags f,
      const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::tmx20::g_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::tmx20::g >
  g_ (::xercesc::InputSource& i,
      ::xml_schema::flags f,
      const ::xml_schema::properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    ::std::auto_ptr< ::tmx20::g > r (
      ::tmx20::g_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::tmx20::g >
  g_ (::xercesc::InputSource& i,
      ::xml_schema::error_handler& h,
      ::xml_schema::flags f,
      const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::tmx20::g > r (
      ::tmx20::g_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::tmx20::g >
  g_ (::xercesc::InputSource& i,
      ::xercesc::DOMErrorHandler& h,
      ::xml_schema::flags f,
      const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::tmx20::g > r (
      ::tmx20::g_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::tmx20::g >
  g_ (const ::xercesc::DOMDocument& d,
      ::xml_schema::flags f,
      const ::xml_schema::properties& p)
  {
    if (f & ::xml_schema::flags::keep_dom)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

      ::std::auto_ptr< ::tmx20::g > r (
        ::tmx20::g_ (
          c, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    const ::xercesc::DOMElement& e (*d.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "g" &&
        n.namespace_ () == "http://www.lisa.org/tmx20")
    {
      ::std::auto_ptr< ::tmx20::g > r (
        ::xsd::cxx::tree::traits< ::tmx20::g, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "g",
      "http://www.lisa.org/tmx20");
  }

  ::std::auto_ptr< ::tmx20::g >
  g_ (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
      ::xml_schema::flags f,
      const ::xml_schema::properties&)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::flags::keep_dom) &&
       !(f & ::xml_schema::flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "g" &&
        n.namespace_ () == "http://www.lisa.org/tmx20")
    {
      ::std::auto_ptr< ::tmx20::g > r (
        ::xsd::cxx::tree::traits< ::tmx20::g, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "g",
      "http://www.lisa.org/tmx20");
  }

  ::std::auto_ptr< ::tmx20::hi >
  hi_ (const ::std::string& u,
       ::xml_schema::flags f,
       const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    ::std::auto_ptr< ::tmx20::hi > r (
      ::tmx20::hi_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::tmx20::hi >
  hi_ (const ::std::string& u,
       ::xml_schema::error_handler& h,
       ::xml_schema::flags f,
       const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::tmx20::hi > r (
      ::tmx20::hi_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::tmx20::hi >
  hi_ (const ::std::string& u,
       ::xercesc::DOMErrorHandler& h,
       ::xml_schema::flags f,
       const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::tmx20::hi > r (
      ::tmx20::hi_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::tmx20::hi >
  hi_ (::std::istream& is,
       ::xml_schema::flags f,
       const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::tmx20::hi_ (isrc, f, p);
  }

  ::std::auto_ptr< ::tmx20::hi >
  hi_ (::std::istream& is,
       ::xml_schema::error_handler& h,
       ::xml_schema::flags f,
       const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::tmx20::hi_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::tmx20::hi >
  hi_ (::std::istream& is,
       ::xercesc::DOMErrorHandler& h,
       ::xml_schema::flags f,
       const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::tmx20::hi_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::tmx20::hi >
  hi_ (::std::istream& is,
       const ::std::string& sid,
       ::xml_schema::flags f,
       const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::tmx20::hi_ (isrc, f, p);
  }

  ::std::auto_ptr< ::tmx20::hi >
  hi_ (::std::istream& is,
       const ::std::string& sid,
       ::xml_schema::error_handler& h,
       ::xml_schema::flags f,
       const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::tmx20::hi_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::tmx20::hi >
  hi_ (::std::istream& is,
       const ::std::string& sid,
       ::xercesc::DOMErrorHandler& h,
       ::xml_schema::flags f,
       const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::tmx20::hi_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::tmx20::hi >
  hi_ (::xercesc::InputSource& i,
       ::xml_schema::flags f,
       const ::xml_schema::properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    ::std::auto_ptr< ::tmx20::hi > r (
      ::tmx20::hi_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::tmx20::hi >
  hi_ (::xercesc::InputSource& i,
       ::xml_schema::error_handler& h,
       ::xml_schema::flags f,
       const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::tmx20::hi > r (
      ::tmx20::hi_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::tmx20::hi >
  hi_ (::xercesc::InputSource& i,
       ::xercesc::DOMErrorHandler& h,
       ::xml_schema::flags f,
       const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::tmx20::hi > r (
      ::tmx20::hi_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::tmx20::hi >
  hi_ (const ::xercesc::DOMDocument& d,
       ::xml_schema::flags f,
       const ::xml_schema::properties& p)
  {
    if (f & ::xml_schema::flags::keep_dom)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

      ::std::auto_ptr< ::tmx20::hi > r (
        ::tmx20::hi_ (
          c, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    const ::xercesc::DOMElement& e (*d.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "hi" &&
        n.namespace_ () == "http://www.lisa.org/tmx20")
    {
      ::std::auto_ptr< ::tmx20::hi > r (
        ::xsd::cxx::tree::traits< ::tmx20::hi, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "hi",
      "http://www.lisa.org/tmx20");
  }

  ::std::auto_ptr< ::tmx20::hi >
  hi_ (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
       ::xml_schema::flags f,
       const ::xml_schema::properties&)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::flags::keep_dom) &&
       !(f & ::xml_schema::flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "hi" &&
        n.namespace_ () == "http://www.lisa.org/tmx20")
    {
      ::std::auto_ptr< ::tmx20::hi > r (
        ::xsd::cxx::tree::traits< ::tmx20::hi, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "hi",
      "http://www.lisa.org/tmx20");
  }

  ::std::auto_ptr< ::tmx20::ph >
  ph_ (const ::std::string& u,
       ::xml_schema::flags f,
       const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    ::std::auto_ptr< ::tmx20::ph > r (
      ::tmx20::ph_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::tmx20::ph >
  ph_ (const ::std::string& u,
       ::xml_schema::error_handler& h,
       ::xml_schema::flags f,
       const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::tmx20::ph > r (
      ::tmx20::ph_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::tmx20::ph >
  ph_ (const ::std::string& u,
       ::xercesc::DOMErrorHandler& h,
       ::xml_schema::flags f,
       const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::tmx20::ph > r (
      ::tmx20::ph_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::tmx20::ph >
  ph_ (::std::istream& is,
       ::xml_schema::flags f,
       const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::tmx20::ph_ (isrc, f, p);
  }

  ::std::auto_ptr< ::tmx20::ph >
  ph_ (::std::istream& is,
       ::xml_schema::error_handler& h,
       ::xml_schema::flags f,
       const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::tmx20::ph_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::tmx20::ph >
  ph_ (::std::istream& is,
       ::xercesc::DOMErrorHandler& h,
       ::xml_schema::flags f,
       const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::tmx20::ph_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::tmx20::ph >
  ph_ (::std::istream& is,
       const ::std::string& sid,
       ::xml_schema::flags f,
       const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::tmx20::ph_ (isrc, f, p);
  }

  ::std::auto_ptr< ::tmx20::ph >
  ph_ (::std::istream& is,
       const ::std::string& sid,
       ::xml_schema::error_handler& h,
       ::xml_schema::flags f,
       const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::tmx20::ph_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::tmx20::ph >
  ph_ (::std::istream& is,
       const ::std::string& sid,
       ::xercesc::DOMErrorHandler& h,
       ::xml_schema::flags f,
       const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::tmx20::ph_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::tmx20::ph >
  ph_ (::xercesc::InputSource& i,
       ::xml_schema::flags f,
       const ::xml_schema::properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    ::std::auto_ptr< ::tmx20::ph > r (
      ::tmx20::ph_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::tmx20::ph >
  ph_ (::xercesc::InputSource& i,
       ::xml_schema::error_handler& h,
       ::xml_schema::flags f,
       const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::tmx20::ph > r (
      ::tmx20::ph_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::tmx20::ph >
  ph_ (::xercesc::InputSource& i,
       ::xercesc::DOMErrorHandler& h,
       ::xml_schema::flags f,
       const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::tmx20::ph > r (
      ::tmx20::ph_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::tmx20::ph >
  ph_ (const ::xercesc::DOMDocument& d,
       ::xml_schema::flags f,
       const ::xml_schema::properties& p)
  {
    if (f & ::xml_schema::flags::keep_dom)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

      ::std::auto_ptr< ::tmx20::ph > r (
        ::tmx20::ph_ (
          c, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    const ::xercesc::DOMElement& e (*d.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "ph" &&
        n.namespace_ () == "http://www.lisa.org/tmx20")
    {
      ::std::auto_ptr< ::tmx20::ph > r (
        ::xsd::cxx::tree::traits< ::tmx20::ph, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "ph",
      "http://www.lisa.org/tmx20");
  }

  ::std::auto_ptr< ::tmx20::ph >
  ph_ (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
       ::xml_schema::flags f,
       const ::xml_schema::properties&)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::flags::keep_dom) &&
       !(f & ::xml_schema::flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "ph" &&
        n.namespace_ () == "http://www.lisa.org/tmx20")
    {
      ::std::auto_ptr< ::tmx20::ph > r (
        ::xsd::cxx::tree::traits< ::tmx20::ph, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "ph",
      "http://www.lisa.org/tmx20");
  }

  ::std::auto_ptr< ::tmx20::sub >
  sub_ (const ::std::string& u,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    ::std::auto_ptr< ::tmx20::sub > r (
      ::tmx20::sub_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::tmx20::sub >
  sub_ (const ::std::string& u,
        ::xml_schema::error_handler& h,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::tmx20::sub > r (
      ::tmx20::sub_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::tmx20::sub >
  sub_ (const ::std::string& u,
        ::xercesc::DOMErrorHandler& h,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::tmx20::sub > r (
      ::tmx20::sub_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::tmx20::sub >
  sub_ (::std::istream& is,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::tmx20::sub_ (isrc, f, p);
  }

  ::std::auto_ptr< ::tmx20::sub >
  sub_ (::std::istream& is,
        ::xml_schema::error_handler& h,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::tmx20::sub_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::tmx20::sub >
  sub_ (::std::istream& is,
        ::xercesc::DOMErrorHandler& h,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::tmx20::sub_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::tmx20::sub >
  sub_ (::std::istream& is,
        const ::std::string& sid,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::tmx20::sub_ (isrc, f, p);
  }

  ::std::auto_ptr< ::tmx20::sub >
  sub_ (::std::istream& is,
        const ::std::string& sid,
        ::xml_schema::error_handler& h,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::tmx20::sub_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::tmx20::sub >
  sub_ (::std::istream& is,
        const ::std::string& sid,
        ::xercesc::DOMErrorHandler& h,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::tmx20::sub_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::tmx20::sub >
  sub_ (::xercesc::InputSource& i,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    ::std::auto_ptr< ::tmx20::sub > r (
      ::tmx20::sub_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::tmx20::sub >
  sub_ (::xercesc::InputSource& i,
        ::xml_schema::error_handler& h,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::tmx20::sub > r (
      ::tmx20::sub_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::tmx20::sub >
  sub_ (::xercesc::InputSource& i,
        ::xercesc::DOMErrorHandler& h,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::tmx20::sub > r (
      ::tmx20::sub_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::tmx20::sub >
  sub_ (const ::xercesc::DOMDocument& d,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
  {
    if (f & ::xml_schema::flags::keep_dom)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

      ::std::auto_ptr< ::tmx20::sub > r (
        ::tmx20::sub_ (
          c, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    const ::xercesc::DOMElement& e (*d.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "sub" &&
        n.namespace_ () == "http://www.lisa.org/tmx20")
    {
      ::std::auto_ptr< ::tmx20::sub > r (
        ::xsd::cxx::tree::traits< ::tmx20::sub, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "sub",
      "http://www.lisa.org/tmx20");
  }

  ::std::auto_ptr< ::tmx20::sub >
  sub_ (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
        ::xml_schema::flags f,
        const ::xml_schema::properties&)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::flags::keep_dom) &&
       !(f & ::xml_schema::flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "sub" &&
        n.namespace_ () == "http://www.lisa.org/tmx20")
    {
      ::std::auto_ptr< ::tmx20::sub > r (
        ::xsd::cxx::tree::traits< ::tmx20::sub, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "sub",
      "http://www.lisa.org/tmx20");
  }

  ::std::auto_ptr< ::tmx20::x >
  x_ (const ::std::string& u,
      ::xml_schema::flags f,
      const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    ::std::auto_ptr< ::tmx20::x > r (
      ::tmx20::x_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::tmx20::x >
  x_ (const ::std::string& u,
      ::xml_schema::error_handler& h,
      ::xml_schema::flags f,
      const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::tmx20::x > r (
      ::tmx20::x_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::tmx20::x >
  x_ (const ::std::string& u,
      ::xercesc::DOMErrorHandler& h,
      ::xml_schema::flags f,
      const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::tmx20::x > r (
      ::tmx20::x_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::tmx20::x >
  x_ (::std::istream& is,
      ::xml_schema::flags f,
      const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::tmx20::x_ (isrc, f, p);
  }

  ::std::auto_ptr< ::tmx20::x >
  x_ (::std::istream& is,
      ::xml_schema::error_handler& h,
      ::xml_schema::flags f,
      const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::tmx20::x_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::tmx20::x >
  x_ (::std::istream& is,
      ::xercesc::DOMErrorHandler& h,
      ::xml_schema::flags f,
      const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::tmx20::x_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::tmx20::x >
  x_ (::std::istream& is,
      const ::std::string& sid,
      ::xml_schema::flags f,
      const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::tmx20::x_ (isrc, f, p);
  }

  ::std::auto_ptr< ::tmx20::x >
  x_ (::std::istream& is,
      const ::std::string& sid,
      ::xml_schema::error_handler& h,
      ::xml_schema::flags f,
      const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::tmx20::x_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::tmx20::x >
  x_ (::std::istream& is,
      const ::std::string& sid,
      ::xercesc::DOMErrorHandler& h,
      ::xml_schema::flags f,
      const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::tmx20::x_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::tmx20::x >
  x_ (::xercesc::InputSource& i,
      ::xml_schema::flags f,
      const ::xml_schema::properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    ::std::auto_ptr< ::tmx20::x > r (
      ::tmx20::x_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::tmx20::x >
  x_ (::xercesc::InputSource& i,
      ::xml_schema::error_handler& h,
      ::xml_schema::flags f,
      const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::tmx20::x > r (
      ::tmx20::x_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::tmx20::x >
  x_ (::xercesc::InputSource& i,
      ::xercesc::DOMErrorHandler& h,
      ::xml_schema::flags f,
      const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::tmx20::x > r (
      ::tmx20::x_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::tmx20::x >
  x_ (const ::xercesc::DOMDocument& d,
      ::xml_schema::flags f,
      const ::xml_schema::properties& p)
  {
    if (f & ::xml_schema::flags::keep_dom)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

      ::std::auto_ptr< ::tmx20::x > r (
        ::tmx20::x_ (
          c, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    const ::xercesc::DOMElement& e (*d.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "x" &&
        n.namespace_ () == "http://www.lisa.org/tmx20")
    {
      ::std::auto_ptr< ::tmx20::x > r (
        ::xsd::cxx::tree::traits< ::tmx20::x, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "x",
      "http://www.lisa.org/tmx20");
  }

  ::std::auto_ptr< ::tmx20::x >
  x_ (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
      ::xml_schema::flags f,
      const ::xml_schema::properties&)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::flags::keep_dom) &&
       !(f & ::xml_schema::flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "x" &&
        n.namespace_ () == "http://www.lisa.org/tmx20")
    {
      ::std::auto_ptr< ::tmx20::x > r (
        ::xsd::cxx::tree::traits< ::tmx20::x, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "x",
      "http://www.lisa.org/tmx20");
  }
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

